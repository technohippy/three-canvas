<link rel="import" href="bower_components/polymer/polymer.html">

<script src="bower_components/threejs/build/three.js"></script>

<!-- controls -->
<script src="bower_components/three.js-controls/src/FirstPersonControls.js"></script>
<script src="bower_components/three.js-controls/src/FlyControls.js"></script>
<script src="bower_components/three.js-controls/src/OrbitControls.js"></script>

<!-- loaders -->
<script src="vendors/three.js/examples/js/loaders/OBJLoader.js"></script>

<!-- postprocess -->
<script src="vendors/three.js/examples/js/shaders/CopyShader.js"></script>
<script src="vendors/three.js/examples/js/shaders/DotScreenShader.js"></script>
<script src="vendors/three.js/examples/js/shaders/RGBShiftShader.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/EffectComposer.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/MaskPass.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/RenderPass.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/ShaderPass.js"></script>

<!-- utils -->
<script>
  THREE.Element = THREE.Element || {Utils:{}};
  THREE.Element.Utils.vector3 = function(val) {
    if (typeof val === 'undefined') {
      return new THREE.Vector3();
    }
    else if (val instanceof THREE.Vector3) {
      return val;
    }
    else if (typeof val === 'string') { // ex) 1,2,3
      try {
        var vals = eval('[' + val + ']');
        return new THREE.Vector3(vals[0], vals[1], vals[2]);
      }
      catch (e) {
        console.log('invalid args: ' + val);
        throw e;
      }
    }
    else {
      console.log('invalid argument: ', val);
      throw 'invalid argument: ' + val;
    }
  };
  THREE.Element.Utils.euler = function(val) {
    if (typeof val === 'undefined') {
      return new THREE.Euler();
    }
    else if (val instanceof THREE.Euler) {
      return val;
    }
    else if (typeof val === 'string') { // ex) 1,2,3
      try {
        var vals = eval('[' + val + ']');
        return new THREE.Euler(vals[0], vals[1], vals[2], vals[3]);
      }
      catch (e) {
        console.log('invalid args: ' + val);
        throw e;
      }
    }
    else {
      console.log('invalid argument: ', val);
      throw 'invalid argument: ' + val;
    }
  };
  THREE.Element.Utils.constant = function(val) {
    if (typeof val === 'string' && /^THREE\./.test(val)) {
      var parts = val.split('.');
      parts.shift();
      var value = THREE;
      while (parts.length !== 0) {
        value = value[parts.shift()];
      }
      return value;
    }
    else {
      return val;
    }
  };
  THREE.Element.Utils.replaceNodeName = function(oldElement, newElementName) {
    var newElement = document.createElement(newElementName);
    oldElement['addEventListener'] = function(eventName, handelr) {
      newElement.addEventListener(eventName, handelr);
    };
    Array.apply(null, oldElement.attributes).forEach(function(attr) {
      newElement.setAttribute(attr.name, attr.value);
    });
    Array.apply(null, oldElement.children).forEach(function(child) {
      newElement.appendChild(child);
    });
    if (oldElement.parentNode) {
      oldElement.parentNode.insertBefore(newElement, oldElement); 
      oldElement.parentNode.removeChild(oldElement);
    }
  };
</script>

<!-- behaviors -->
<script>
  ThreeObjectBehavior = {
    properties: {
      object: Object,
      isThreeObject: {
        type: Boolean,
        value: true,
        readOnly: true
      }
    },
    getParentThreeNode: function(localNames, currentNode) {
      if (typeof currentNode === 'undefined') currentNode = this;
      if (typeof localNames === 'undefined') localNames = ['three-engine'];
      if (typeof localNames === 'string') localNames = [localNames];
      var cursor = currentNode.parentNode;
      if (cursor.nodeType === 11) { // #document-fragment
        cursor = cursor.host.parentNode;
      }
      while (cursor.localName !== 'body') {
        for (var i = 0; i < localNames.length; i++) {
          var localName = localNames[i];
          if (cursor.localName === localName) return cursor;
        }
        if (cursor.shadowRoot) {
          var contents = cursor.shadowRoot.querySelectorAll('content');
          for (var j = 0; j < contents.length; j++) {
            var found = this.getParentThreeNode(localNames, contents[j]);
            if (found) return found;
          }
        }
        cursor = cursor.parentNode;
        if (cursor.nodeType === 11) { // #document-fragment
          cursor = cursor.host.parentNode;
        }
      }
      return null;
    },
    _vector3: function(val) {
      return THREE.Element.Utils.vector3(val);
    },
    _euler: function(val) {
      return THREE.Element.Utils.euler(val);
    }
  };
  ThreeObject3dBehavior = {
    properties: {
      name: {
        type: String
      },
      position: {
        type: String,
        value: '0,0,0',
        reflectToAttribute: true,
        notify: true
      },
      rotation: {
        type: String,
        value: '0,0,0',
        reflectToAttribute: true,
        notify: true
      },
      scale: {
        type: String,
        value: '1,1,1',
        reflectToAttribute: true,
        notify: true
      },
      castShadow: {
        type: Boolean,
        value: false
      },
      receiveShadow: {
        type: Boolean,
        value: false
      }
    },
    _positionChanged: function(newVal, oldVal) {
      this.position = this._vector3(newVal);
      if (typeof this.object !== 'undefined') {
        this.object.position.copy(this.position);
      }
    },
    _rotationChanged: function(newVal, oldVal) {
      this.rotation = this._euler(newVal);
      if (typeof this.object !== 'undefined') {
        this.object.rotation.copy(this.rotation);
      }
    },
    _scaleChanged: function(newVal, oldVal) {
      this.scale = this._vector3(newVal);
      if (typeof this.object !== 'undefined') {
        this.object.scale.copy(this.scale);
      }
    }
  };
  ThreeLightBehavior = {
    properties: {
      light: Object,
      color: {
        type: String,
        value: '#ffffff'
      }
    }
  };
  ThreeMaterialBehavior = {
    properties: {
      side: {
        type: Number,
        value: THREE.FrontSide
      },
      opacity: {
        type: Number,
        value: 1
      },
      transparent: {
        type: Number,
        value: false
      },
      blending: {
        type: Number,
        value: THREE.NormalBlending
      },
      blendSrc: {
        type: Number,
        value: THREE.SrcAlphaFactor
      },
      blendDst: {
        type: Number,
        value: THREE.OneMinusSrcAlphaFactor
      },
      blendEquation: {
        type: Number,
        value: THREE.AddEquation
      },
      depthTest: {
        type: Boolean,
        value: true
      },
      depthWrite: {
        type: Boolean,
        value: true
      },
      polygonOffset: {
        type: Boolean,
        value: false
      },
      polygonOffsetFactor: {
        type: Number,
        value: 0
      },
      polygonOffsetUnits: {
        type: Number,
        value: 0
      },
      alphaTest: {
        type: Number,
        value: 0
      },
      overdraw: {
        type: Number,
        value: 0
      },
      visible: {
        type: Boolean,
        value: true
      }
    },
    _getOptions: function() {
      if (this.opacity < 1) this.transparent = true;
      return {
        side: this.side,
        opacity: this.opacity,
        transparent: this.transparent,
        blending: this.blending,
        blendSrc: this.blendSrc,
        blendDst: this.blendDst,
        blendEquation: this.blendEquation,
        depthTest: this.depthTest,
        depthWrite: this.depthWrite,
        polygonOffset: this.polygonOffset,
        polygonOffsetFactor: this.polygonOffsetFactor,
        polygonOffsetUnits: this.polygonOffsetUnits,
        alphaTest: this.alphaTest,
        overdraw: this.overdraw,
        visible: this.visible
      };
    }
  };
  ThreeMeshPhongMaterializedMeshBehavior = {
    properties: {
/*
      side: {
        type: Number,
        value: 0
      },
      opacity: {
        type: Number,
        value: 0
      },
      transparent: {
        type: Number,
        value: 0
      },
      blending: {
        type: Number,
        value: 0
      },
      blendSrc: {
        type: Number,
        value: 0
      },
      blendDst: {
        type: Number,
        value: 0
      },
      blendEquation: {
        type: Number,
        value: 0
      },
      depthTest: {
        type: Number,
        value: 0
      },
      depthWrite: {
        type: Number,
        value: 0
      },
      polygonOffset: {
        type: Number,
        value: 0
      },
      polygonOffsetFactor: {
        type: Number,
        value: 0
      },
      polygonOffsetUnits: {
        type: Number,
        value: 0
      },
      alphaTest: {
        type: Number,
        value: 0
      },
      overdraw: {
        type: Number,
        value: 0
      },
      visible: {
        type: Number,
        value: 0
      },
*/
      color: {
        type: String
      },
/*
      ambient: {
        type: Number,
        value: 0
      },
      emissive: {
        type: Number,
        value: 0
      },
      specular: {
        type: Number,
        value: 0
      },
      shininess: {
        type: Number,
        value: 0
      },
      metal: {
        type: Number,
        value: 0
      },
*/
      map: {
        type: String
      },
/*
      bumpMap: {
        type: Number,
        value: 0
      },
      bumpScale: {
        type: Number,
        value: 0
      },
      fog: {
        type: Number,
        value: 0
      },
      shading: {
        type: Number,
        value: 0
      },
      wireframe: {
        type: Number,
        value: 0
      }
*/
    }
  };
  ThreeSphereGeometryBehavior = {
    properties: {
      radius: {
        type: Number,
        value: 50
      },
      widthSegments: {
        type: Number,
        value: 32
      },
      heightSegments: {
        type: Number,
        value: 16
      },
      phiStart: {
        type: Number,
        value: 0
      },
      phiLength: {
        type: Number,
        value: Math.PI * 2
      },
      thetaStart: {
        type: Number,
        value: 0
      },
      thetaLength: {
        type: Number,
        value: Math.PI
      }
    },
  };

  ThreeBoxGeometryBehavior = {
    properties: {
      width: {
        type: Number,
        value: 1 
      },
      height: {
        type: Number,
        value: 1 
      },
      depth: {
        type: Number,
        value: 1 
      },
      widthSegments: {
        type: Number,
        value: 1 
      },
      heightSegments: {
        type: Number,
        value: 1
      },
      depthSegments: {
        type: Number,
        value: 1
      }
    }
  };

  ThreeCircleGeometryBehavior = {
    properties: {
      radius: {
        type: Number,
        value: 50
      },
      segments: {
        type: Number,
        value: 32
      },
      thetaStart: {
        type: Number,
        value: 0
      },
      thetaLength: {
        type: Number,
        value: Math.PI * 2
      }
    }
  };

  ThreeCylinderGeometryBehavior = {
    properties: {
      radiusTop: {
        type: Number,
        value: 20.0
      },
      radiusBottom: {
        type: Number,
        value: 20.0
      },
      height: {
        type: Number,
        value: 100.0
      },
      radialSegments: {
        type: Number,
        value: 32
      },
      heightSegments: {
        type: Number,
        value: 1
      },
      openEnded: {
        type: Boolean,
        value: false
      },
      thetaStart: {
        type: Number,
        value: 0
      },
      thetaLength: {
        type: Number,
        value: 2 * Math.PI
      }
    }
  };

  ThreePlaneGeometryBehavior = {
    properties: {
      width: {
        type: Number,
        value: 1
      },
      height: {
        type: Number,
        value: 1
      },
      widthSegments: {
        type: Number,
        value: 1
      },
      heightSegments: {
        type: Number,
        value: 1
      }
    }
  };

  ThreeTorusGeometryBehavior = {
    properties: {
      radius: {
        type: Number,
        value: 100
      },
      tube: {
        type: Number,
        value: 40
      },
      radialSegments: {
        type: Number,
        value: 16
      },
      tubularSegments: {
        type: Number,
        value: 32
      },
      arc: {
        type: Number,
        value: Math.PI * 2
      }
    }
  };

  ThreeShaderVariableContainerBehavior = {
    properties: {
      variableOptions: {
        type: Object,
        value: function() { return {}; }
      }
    },
    addVariable: function(name, definition, content) {
      // TODO: ignoring content for the time being
      this.variableOptions[name] = definition;
      var materialElement = this.getParentThreeNode('three-shader-material');
      if (materialElement) {
        materialElement.resetMaterial();
      }
    }
  };

  ThreeShaderVariablesContainerBehavior = {
    properties: {
      uniformsElements: {
        type: Array,
        value: function() { return []; }
      },
      attributesElements: {
        type: Array,
        value: function() { return []; }
      },
    },
    getShaderOptions: function() {
      var shaderOptions = {};
      this.uniformsElements.forEach(function(uniformsElement) {
        uniformOptions = {};
        for(var name in uniformsElement.variableOptions) {
          uniformOptions[name] = uniformsElement.variableOptions[name];
        }
        shaderOptions['uniforms'] = uniformOptions;
      });
      this.attributesElements.forEach(function(attributesElement) {
        attributeOptions = {};
        for(name in attributeOptions.variableOptions) {
          attributeOptions[name] = attributeOptions.variableOptions[name];
        }
        shaderOptions['attributes'] = attributeOptions;
      });
      return shaderOptions;
    }
  };

  ThreeShaderBehavior = {
    getShader: function() {
      return this.textContent;
    }
  };
</script>

<!-- components -->
<dom-module id="three-engine">
  <script>
    Polymer({
      is: 'three-engine',
      behaviors: [
        ThreeObjectBehavior
      ],
      properties: {
        fullscreen: {
          type: Boolean,
          value: false
        },
        width: {
          type: Number,
          value: 0
        },
        height: {
          type: Number,
          value: 0
        },
        canvas: String,
        canvasElement: Object,
        renderer: Object,
        scene: Object,
        camera: Object,
        controls: Object,
        rendererElement: {
          type: Object,
          observer: '_rendererElementChanged'
        },
        sceneElement: {
          type: Object,
          observer: '_sceneElementChanged'
        },
        cameraElement: {
          type: Object,
          observer: '_cameraElementChanged'
        },
        controlsElement: {
          type: Object,
          observer: '_controlsElementChanged'
        },
        shadowEnabled: {
          type: Boolean,
          value: false
        }
      },
      render: function() {
        if (this.composer) {
          this.composer.render();
        }
        else {
          if (!this.renderer) throw 'no renderer';
          if (!this.scene) throw 'no scene';
          if (!this.camera) throw 'no camera';
          this.renderer.render(this.scene, this.camera);
          if (this.rendererElement.shaderPassElement) {
            this.composer = this.rendererElement.getComposer(this);
          }
        }
      },
      start: function() {
        var canvasElement = this.getParentThreeNode('three-canvas') || this.domHost;
        if (canvasElement) {
          canvasElement.renderer = this.renderer;
          canvasElement.scene = this.scene;
          canvasElement.camera = this.camera;
        }
        if (this.fullscreen) {
          window.addEventListener('resize', function() {
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
          }.bind(this), false);
        }

        var clock = new THREE.Clock();
        ((function animate() {
          try {
            this.render();
            this.fire('render');
            if (this.controls) this.controls.update(clock.getDelta());
            requestAnimationFrame(animate.bind(this));
          }
          catch (e) {
            console.log('animate error:' + e);
          }
        }).bind(this))();
        if (!this.controls && this.controlsElement) {
          this.controls = this.controlsElement.getControls(this.camera, this.canvasElement);
        }
/*
window.addEventListener('WebComponentsReady', function() {
  if (this.rendererElement.shaderPassElement) {
    this.composer = this.rendererElement.getComposer(this);
  }
}.bind(this));
*/
      },
      _setupCanvas: function() {
        if (this.canvas) {
          this.canvasElement = document.getElementById(this.canvas);
        }
        else if (this.previousElementSibling && this.previousElementSibling.tagName === 'CANVAS') {
          this.canvasElement = this.previousElementSibling;
        }
        else {
          if (this.width === 0 || this.height === 0) {
            if (this.fullscreen) {
              this.width = window.innerWidth;
              this.height = window.innerHeight;
            }
            else {
              throw 'no canvas';
            }
          }
          this.canvasElement = document.createElement('canvas');
          this.canvasElement.width = this.width;
          this.canvasElement.height = this.height;
          if (this.fullscreen) {
            this.canvasElement.style.margin = 0;
            this.canvasElement.style.padding = 0;
            this.canvasElement.style.position = 'absolute';
            this.canvasElement.style.top = 0;
            this.canvasElement.style.left = 0;
          }
          this.parentNode.insertBefore(this.canvasElement, this);
        }
      },
      getCanvas: function() {
        if (!this.canvasElement) this._setupCanvas();
        return this.canvasElement;
      },
      _rendererElementChanged: function(newValue, oldValue) {
        this.renderer = this.rendererElement.getRenderer(this);
        if (this.rendererElement.composer) {
          this.composer = this.rendererElement.composer;
        }

        if (this.sceneElement && this.cameraElement) this.start();
      },
      _sceneElementChanged: function(newValue, oldValue) {
        this.scene = this.sceneElement.getScene();

        if (this.rendererElement && this.cameraElement) this.start();
      },
      _cameraElementChanged: function(newValue, oldValue) {
        this.camera = this.cameraElement.getCamera();

        if (this.rendererElement && this.sceneElement) this.start();
      },
      _controlsElementChanged: function(newValue, oldValue) {
        if (!this.controls && this.camera && this.canvasElement) {
          this.controls = this.controlsElement.getControls(this.camera, this.canvasElement);
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-renderer">
  <script>
    Polymer({
      is: 'three-renderer',
      behaviors: [
        ThreeObjectBehavior
      ],
      properties: {
        precision: {
          type: String,
          value: 'highp'
        },
        alpha: {
          type: Boolean,
          value: false
        },
        depth: {
          type: Boolean,
          value: true
        },
        stencil: {
          type: Boolean,
          value: true
        },
        antialias: {
          type: Boolean,
          value: false
        },
        premultipliedAlpha: {
          type: Boolean,
          value: true
        },
        preserveDrawingBuffer: {
          type: Boolean,
          value: false
        },
        logarithmicDepthBuffer: {
          type: Boolean,
          value: false
        },
        clearColor: {
          type: String,
          value: '#000000'
        },
        autoClear: {
          type: Boolean,
          value: true
        },
        autoClearColor: {
          type: Boolean,
          value: true
        },
        autoClearDepth: {
          type: Boolean,
          value: true
        },
        autoClearStencil: {
          type: Boolean,
          value: true
        },
        sortObjects: {
          type: Boolean,
          value: true
        },
        gammaInput: {
          type: Boolean,
          value: false
        },
        gammaOutput: {
          type: Boolean,
          value: false
        },
        shadowMapEnabled: {
          type: Boolean,
          value: false
        },
        shadowMapType: {
          type: Number,
          value: THREE.PCFShadowMap
        },
        shadowMapCullFace: {
          type: Number,
          value: THREE.CullFaceFront
        },
        shadowMapDebug: {
          type: Boolean,
          value: false
        },
        shadowMapCascade: {
          type: Boolean,
          value: false
        },
        maxMorphTargets: {
          type: Number,
          value: 8
        },
        maxMorphNormals: {
          type: Number,
          value: 4
        },
        autoScaleCubemaps: {
          type: Boolean,
          value: true
        },
        shaderPassElement: Object,
        composer: Object
      },
      attached: function() {
        var engineElement = this.getParentThreeNode('three-engine');
        if (engineElement) {
          engineElement.rendererElement = this;
        }
      },
      getRenderer: function(engineElement) {
        if (this.renderer) return this.renderer;

        this.renderer = new THREE.WebGLRenderer({
          canvas: engineElement.getCanvas(),
          precision:this.precision,
          alpha:this.alpha,
          depth:this.depth,
          stencil:this.stencil,
          antialias:this.antialias,
          premultipliedAlpha:this.premultipliedAlpha,
          preserveDrawingBuffer:this.preserveDrawingBuffer,
          logarithmicDepthBuffer:this.logarithmicDepthBuffer
        });
        this.renderer.setClearColor(new THREE.Color(this.clearColor), 1);
        this.renderer.autoClear = this.autoClear;
        this.renderer.autoClearColor = this.autoClearColor;
        this.renderer.autoClearDepth = this.autoClearDepth;
        this.renderer.autoClearStencil = this.autoClearStencil;
        this.renderer.sortObjects = this.sortObjects;
        this.renderer.gammaInput = this.gammaInput;
        this.renderer.gammaOutput = this.gammaOutput;
        this.renderer.shadowMapEnabled = this.shadowMapEnabled || engineElement.shadowEnabled;
        this.renderer.shadowMapType = this.shadowMapType;
        this.renderer.shadowMapCullFace = this.shadowMapCullFace;
        this.renderer.shadowMapDebug = this.shadowMapDebug;
        this.renderer.shadowMapCascade = this.shadowMapCascade;
        this.renderer.maxMorphTargets = this.maxMorphTargets;
        this.renderer.maxMorphNormals = this.maxMorphNormals;
        this.renderer.autoScaleCubemaps = this.autoScaleCubemaps;

        if (this.shaderPassElement) this.getComposer(engineElement);
        return this.renderer;
      },
      getComposer: function(engineElement) {
        this.composer = new THREE.EffectComposer(this.renderer);
        this.composer.addPass(new THREE.RenderPass(engineElement.scene, engineElement.camera));
        this.shaderPassElement.getShaderPass().forEach(function(effect) {
          this.composer.addPass(effect);
        }.bind(this));
        return this.composer;
      }
    });
  </script>
</dom-module>

<dom-module id="three-scene">
  <script>
    Polymer({
      is: 'three-scene',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior
      ],
      properties: {
        scene: Object
      },
      created: function() {
        this.scene = new THREE.Scene();
      },
      attached: function() {
        var engineElement = this.getParentThreeNode('three-engine');
        if (engineElement) {
          engineElement.sceneElement = this;
        }
      },
      getScene: function() {
        return this.scene;
      }
    });
  </script>
</dom-module>

<dom-module id="three-camera">
  <script>
    Polymer({
      is: 'three-camera',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior
      ],
      properties: {
        type: {
          type: String,
          value: 'perspective'
        }
      },
      ready: function() {
        THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-camera');
      }
    });
  </script>
</dom-module>

<dom-module id="three-perspective-camera">
  <script>
    Polymer({
      is: 'three-perspective-camera',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        lookAt: {
          type: String,
          observer: '_lookAtChanged'
        },
        controls: String
      },
      attached: function() {
        var engineElement = this.getParentThreeNode('three-engine');
        var canvas = engineElement.getCanvas();

        var aspect = canvas.width / canvas.height;
        this.camera = new THREE.PerspectiveCamera(15, aspect);
        this.camera.userData['element'] = this;
        this.camera.position.copy(this._vector3(this.position));
        this.camera.lookAt(this._vector3(this.lookAt));
        if (this.name) this.camera.name = this.name;
        this.object = this.camera;

        if (this.controls === 'orbit') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'orbit');
          controlsElm.setAttribute('center', this.lookAt);
          this.appendChild(controlsElm);
        }
        else if (this.controls === 'fly') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'fly');
          this.appendChild(controlsElm);
        }
        else if (this.controls === 'firstperson') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'firstperson');
          this.appendChild(controlsElm);
        }

        var sceneElement = this.getParentThreeNode('three-scene');
        sceneElement.getScene().add(this.camera);

        engineElement.cameraElement = this;
      },
      getCamera: function() {
        return this.camera;
      },
      _lookAtChanged: function(newVal, oldVal) {
        if (typeof this.camera !== 'undefined') {
          this.camera.lookAt(this.vector3(newVal));
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-light">
  <script>
    Polymer({
      is: 'three-light',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        type: {
          type: String,
          value: 'directional'
        },
        color: {
          type: String,
          value: '#ffffff'
        }
      },
      ready: function() {
        THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-light');
      }
    });
  </script>
</dom-module>

<dom-module id="three-directional-light">
  <script>
    Polymer({
      is: 'three-directional-light',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeLightBehavior
      ],
      properties: {
        type: {
          type: String,
          value: 'directional'
        },
        intensity: {
          type: Number,
          value: 1
        },
        onlyShadow: {
          type: Boolean,
          value: false
        },
        shadowCameraNear: {
          type: Number,
          value: 50
        },
        shadowCameraFar: {
          type: Number,
          value: 5000
        },
        shadowCameraLeft: {
          type: Number,
          value: -500
        },
        shadowCameraRight: {
          type: Number,
          value: 500
        },
        shadowCameraTop: {
          type: Number,
          value: 500
        },
        shadowCameraBottom: {
          type: Number,
          value: -500
        },
        shadowCameraVisible: {
          type: Boolean,
          value: false
        },
        shadowBias: {
          type: Number,
          value: 0
        },
        shadowDarkness: {
          type: Number,
          value: 0.5
        },
        shadowMapWidth: {
          type: Number,
          value: 512
        },
        shadowMapHeight: {
          type: Number,
          value: 512
        }
      },
      attached: function() {
        this.light = new THREE.DirectionalLight(new THREE.Color(this.color));
        this.light.position.copy(this._vector3(this.position));
        this.light.shadowMapWidth = this.shadowMapWidth;
        this.light.shadowMapHeight = this.shadowMapHeight;
        this.light.castShadow = this.castShadow;
        if (this.name) this.light.name = this.name;

        var sceneElement = this.getParentThreeNode('three-scene');
        sceneElement.getScene().add(this.light);
      }
    });
  </script>
</dom-module>

<dom-module id="three-ambient-light">
  <script>
    Polymer({
      is: 'three-ambient-light',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeLightBehavior],
      attached: function() {
        this.light = new THREE.AmbientLight(new THREE.Color(this.color));
        if (this.name) this.light.name = this.name;

        var sceneElement = this.getParentThreeNode('three-scene');
        sceneElement.getScene().add(this.light);
      }
    });
  </script>
</dom-module>

<dom-module id="three-mesh">
  <script>
    Polymer({
      is: 'three-mesh',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        materialElement: {
          type: Object,
          observer: '_materialElementChanged'
        },
        geometryElement: {
          type: Object,
          observer: '_geometryElementChanged'
        },
        geometryElements: {
          type: Array,
          value: function() {return [];}
        },
        childMeshElements: {
          type: Array,
          value: function() {return [];}
        },
        material: Object,
        geometry: Object,
        mesh: Object
      },
      _materialElementChanged: function(newVal, oldVal) {
        this.material = this.materialElement.getMaterial();
        if (this._needCreateMesh()) this.createMesh();
      },
      _geometryElementChanged: function(newVal, oldVal) {
        this.geometry = this.geometryElement.getGeometry();
        if (this._needCreateMesh()) this.createMesh();
      },
      _needCreateMesh: function() {
        if (this.geometry) {
          if (this.material || this.getParentThreeNode('three-mesh')) return true;
        }
        return false;
      },
      addGeometryElement: function(element) {
        this.geometryElements.push(element);
        var geometry = element.getGeometry();
        if (!this.geometry) {
          this.geometry = geometry;
          if (this._needCreateMesh()) this.createMesh();
        }
        else {
          this.geometry.merge(geometry);
        }
      },
      addChildMeshElement: function(element) {
        this.childMeshElements.push(element);
        this.createMesh();
      },
      removeMeshElement: function(element) {
        this.childMeshElements.splice(this.childMeshElements.indexOf(element), 1);
      },
      createMesh: function(fromParent) {
        var oldMesh = this.mesh;

        this.geometry = new THREE.Geometry();
        for (var i = 0; i < this.geometryElements.length; i++) {
          this.geometry.merge(this.geometryElements[i].getGeometry());
        }
        for (i = 0; i < this.childMeshElements.length; i++) {
          var childMesh = this.childMeshElements[i].createMesh(true);
          childMesh.updateMatrix();
          this.geometry.merge(childMesh.geometry, childMesh.matrix);
        }

        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.position.copy(this._vector3(this.position));
        this.mesh.rotation.copy(this._euler(this.rotation));
        this.mesh.scale.copy(this._vector3(this.scale));
        this.mesh.castShadow = this.castShadow;
        this.mesh.receiveShadow = this.receiveShadow;
        if (this.name) this.mesh.name = this.name;

        if (!fromParent) {
          var element = this.getParentThreeNode(['three-mesh', 'three-scene']);
          if (oldMesh && element.localName === 'three-scene') {
            element.getScene().remove(oldMesh);
          }
          if (element.localName === 'three-scene') {
            element.getScene().add(this.mesh);
          }
          else if (element.localName === 'three-mesh') {
            element.addChildMeshElement(this);
          }
        }

        return this.mesh;
      }
    });
  </script>
</dom-module>

<dom-module id="three-material">
  <script>
    Polymer({
      is: 'three-material',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeMaterialBehavior],
      properties: {
        type: {
          type: String,
          value: 'mesh-phong'
        },
        ref: String
      },
      ready: function() {
        if (!this.ref) {
          THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-material');
        }
      },
      attached: function() {
        if (this.ref) {
          this.material = document.getElementById(this.ref).getMaterial();

          var meshElement = this.getParentThreeNode('three-mesh');
          meshElement.materialElement = this;
        }
      },
      getMaterial: function() {
        return this.material;
      }
    });
  </script>
</dom-module>

<dom-module id="three-mesh-phong-material">
  <script>
    Polymer({
      is: 'three-mesh-phong-material',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeMaterialBehavior],
      properties: {
        color: {
          type: String,
          value: '#ffffff'
        },
        ambient: {
          type: String,
          value: '#ffffff'
        },
        emissive: {
          type: String,
          value: '#000000'
        },
        specular: {
          type: String,
          value: '#000000'
        },
        shininess: {
          type: Number,
          value: 30
        },
        metal: {
          type: Boolean,
          value: false
        },
        map: {
          type: String,
          value: ''
        },
        bumpMap: {
          type: String,
          value: ''
        },
        bumpScale: {
          type: Number,
          value: 1
        },
        fog: {
          type: Boolean,
          value: true
        },
        shading: {
          type: Number,
          value: THREE.SmoothShading
        },
        wireframe: {
          type: Boolean,
          value: false
        }
      },
      attached: function() {
        this.material = new THREE.MeshPhongMaterial(this._getOptions());
        if (this.map !== '') {
          this.material.map = THREE.ImageUtils.loadTexture(this.map);
        }
        if (this.bumpMap !== '') {
          this.material.bumpMap = THREE.ImageUtils.loadTexture(this.bumpMap);
        }

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.materialElement = this;
      },
      getMaterial: function() {
        return this.material;
      },
      _getOptions: function() {
        var opts = ThreeMaterialBehavior._getOptions.call(this);
        opts['color'] = new THREE.Color(this.color);
        opts['ambient'] = new THREE.Color(this.ambient);
        opts['emissive'] = new THREE.Color(this.emissive);
        opts['specular'] = new THREE.Color(this.specular);
        opts['shininess'] = this.shininess;
        opts['metal'] = this.metal;
        opts['bumpScale'] = this.bumpScale;
        opts['fog'] = this.fog;
        opts['shading'] = this.shading;
        opts['wireframe'] = this.wireframe;
        return opts;
      }
    });
  </script>
</dom-module>

<dom-module id="three-sphere-geometry">
  <script>
    Polymer({
      is: 'three-sphere-geometry',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeSphereGeometryBehavior
      ],
      attached: function() {
        this.geometry = new THREE.SphereGeometry(this.radius, this.widthSegments, this.heightSegments, this.phiStart, this.phiLength, this.thetaStart, this.thetaLength);

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.addGeometryElement(this);
      },
      getGeometry: function() {
        return this.geometry;
      }
    });
  </script>
</dom-module>

<dom-module id="three-box-geometry">
  <script>
    Polymer({
      is: 'three-box-geometry',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeBoxGeometryBehavior
      ],
      attached: function() {
        this.geometry = new THREE.BoxGeometry(this.width, this.height, this.depth, this.widthSegments, this.heightSegments, this.depthSegments);

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.addGeometryElement(this);
      },
      getGeometry: function() {
        return this.geometry;
      }
    });
  </script>
</dom-module>

<dom-module id="three-circle-geometry">
  <script>
    Polymer({
      is: 'three-circle-geometry',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeCircleGeometryBehavior
      ],
      attached: function() {
        this.geometry = new THREE.CircleGeometry(this.radius, this.segments, this.thetaStart, this.thetaLength);

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.addGeometryElement(this);
      },
      getGeometry: function() {
        return this.geometry;
      }
    });
  </script>
</dom-module>

<dom-module id="three-cylinder-geometry">
  <script>
    Polymer({
      is: 'three-cylinder-geometry',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeCylinderGeometryBehavior
      ],
      attached: function() {
        this.geometry = new THREE.CylinderGeometry(this.radiusTop, this.radiusBottom, this.height, this.radialSegments, this.heightSegments, this.openEnded, this.thetaStart, this.thetaLength);

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.addGeometryElement(this);
      },
      getGeometry: function() {
        return this.geometry;
      }
    });
  </script>
</dom-module>

<dom-module id="three-plane-geometry">
  <script>
    Polymer({
      is: 'three-plane-geometry',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreePlaneGeometryBehavior
      ],
      attached: function() {
        // PlaneBufferGeometry breaks three-mesh#createMesh
        //this.geometry = new THREE.PlaneBufferGeometry(this.width, this.height, this.widthSegments, this.heightSegments);
        this.geometry = new THREE.PlaneGeometry(this.width, this.height, this.widthSegments, this.heightSegments);

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.addGeometryElement(this);
      },
      getGeometry: function() {
        return this.geometry;
      }
    });
  </script>
</dom-module>

<dom-module id="three-torus-geometry">
  <script>
    Polymer({
      is: 'three-torus-geometry',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeTorusGeometryBehavior
      ],
      attached: function() {
        this.geometry = new THREE.TorusGeometry(this.radius, this.tube, this.radialSegments, this.tubularSegments, this.arc);

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.addGeometryElement(this);
      },
      getGeometry: function() {
        return this.geometry;
      }
    });
  </script>
</dom-module>

<dom-module id="three-canvas">
  <template>
    <three-engine fullscreen="{{fullscreen}}" width$="{{width}}" height$="{{height}}" shadow-enabled="{{shadowEnabled}}">
      <three-renderer antialias="{{antialias}}" clear-color$="{{clearColor}}">
        <content select="three-shader-pass"></content>
      </three-renderer>
      <three-scene id="scene">
        <content></content>
      </three-scene>
    </three-engine>
  </template>
  <script>
    Polymer({
      is: 'three-canvas',
      behaviors: [ThreeObjectBehavior],
      properties: {
        width: Number,
        height: Number,
        antialias: {
          type: Boolean,
          value: true
        },
        clearColor: String,
        fullscreen: {
          type: Boolean,
          value: false
        },
        defaultLight: {
          type: Boolean,
          value: false
        },
        shadowEnabled: {
          type: Boolean,
          value: false
        },
        renderer: Object,
        scene: Object,
        camera: Object
      },
      ready: function() {
        if (this.defaultLight) {
          /*
          <template is="dom-if" if="{{defaultLight}}">
            <three-directional-light position="0.577,0.577,0.577" color="#cccccc"></three-directional-light>
            <three-ambient-light color="#333333"></three-ambient-light>
          </template>
          */
          var directionalLight = document.createElement('three-directional-light');
          //directionalLight.setAttribute('position', '0.577,0.577,0.577');
          directionalLight.setAttribute('position', '100,100,100');
          directionalLight.setAttribute('color', '#cccccc');
          if (this.shadowEnabled) {
            directionalLight.setAttribute('cast-shadow', true);
          }
          this.$.scene.appendChild(directionalLight);
          var ambientLight = document.createElement('three-ambient-light');
          ambientLight.setAttribute('color', '#333333');
          this.$.scene.appendChild(ambientLight);
        }
      },
      getObjectByName: function(name) {
        return this.scene.getObjectByName(name);
      }
    });
  </script>
</dom-module>

<dom-module id="three-sphere">
  <template>
    <three-mesh
      name="{{name}}"
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      cast-shadow="{{castShadow}}"
      receive-shadow="{{receiveShadow}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blend-src="{{blendSrc}}"
        blend-dst="{{blendDst}}"
        blend-equation="{{blendEquation}}"
        depth-test="{{depthTest}}"
        depth-write="{{depthWrite}}"
        polygon-offset="{{polygonOffset}}"
        polygon-offset-factor="{{polygonOffsetFactor}}"
        polygon-offset-units="{{polygonOffsetUnits}}"
        alpha-test="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bump-map="{{bumpMap}}"
        bump-scale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <three-sphere-geometry
        radius="{{radius}}"
        width-segments="{{widthSegments}}"
        height-segments="{{heightSegments}}"
        phi-start="{{phiStart}}"
        phi-length="{{phiLength}}"
        theta-start="{{thetaStart}}"
        theta-length="{{thetaLength}}">
      </three-sphere-geometry>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      is: 'three-sphere',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeMeshPhongMaterializedMeshBehavior,
        ThreeSphereGeometryBehavior
      ],
      properties: {
        castShadow: {
          type: Boolean,
          value: true
        },
        receiveShadow: {
          type: Boolean,
          value: true
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-box">
  <template>
    <three-mesh
      name="{{name}}"
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      cast-shadow="{{castShadow}}"
      receive-shadow="{{receiveShadow}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blend-src="{{blendSrc}}"
        blend-dst="{{blendDst}}"
        blend-equation="{{blendEquation}}"
        depth-test="{{depthTest}}"
        depth-write="{{depthWrite}}"
        polygon-offset="{{polygonOffset}}"
        polygon-offset-factor="{{polygonOffsetFactor}}"
        polygon-offset-units="{{polygonOffsetUnits}}"
        alpha-test="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bump-map="{{bumpMap}}"
        bump-scale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <three-box-geometry
        width="{{width}}"
        height="{{height}}"
        depth="{{depth}}"
        width-segments="{{widthSegments}}"
        height-segments="{{heightSegments}}"
        depth-segments="{{depthSegments}}">
      </three-box-geometry>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      is: 'three-box',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeMeshPhongMaterializedMeshBehavior,
        ThreeBoxGeometryBehavior
      ],
      properties: {
        castShadow: {
          type: Boolean,
          value: true
        },
        receiveShadow: {
          type: Boolean,
          value: true
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-circle">
  <template>
    <three-mesh
      name="{{name}}"
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      cast-shadow="{{castShadow}}"
      receive-shadow="{{receiveShadow}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blend-src="{{blendSrc}}"
        blend-dst="{{blendDst}}"
        blend-equation="{{blendEquation}}"
        depth-test="{{depthTest}}"
        depth-write="{{depthWrite}}"
        polygon-offset="{{polygonOffset}}"
        polygon-offset-factor="{{polygonOffsetFactor}}"
        polygon-offset-units="{{polygonOffsetUnits}}"
        alpha-test="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bump-map="{{bumpMap}}"
        bump-scale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <three-circle-geometry
        radius="{{radius}}"
        segments="{{segments}}"
        theta-start="{{thetaStart}}"
        theta-length="{{thetaLength}}">
      </three-circle-geometry>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      is: 'three-circle',
      behaviors: [
        ThreeObjectBehavior, 
        ThreeObject3dBehavior,
        ThreeMeshPhongMaterializedMeshBehavior,
        ThreeCircleGeometryBehavior
      ],
      properties: {
        castShadow: {
          type: Boolean,
          value: true
        },
        receiveShadow: {
          type: Boolean,
          value: true
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-cylinder">
  <template>
    <three-mesh
      name="{{name}}"
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      cast-shadow="{{castShadow}}"
      receive-shadow="{{receiveShadow}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blend-src="{{blendSrc}}"
        blend-dst="{{blendDst}}"
        blend-equation="{{blendEquation}}"
        depth-test="{{depthTest}}"
        depth-write="{{depthWrite}}"
        polygon-offset="{{polygonOffset}}"
        polygon-offset-factor="{{polygonOffsetFactor}}"
        polygon-offset-units="{{polygonOffsetUnits}}"
        alpha-test="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bump-map="{{bumpMap}}"
        bump-scale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <three-cylinder-geometry
        radius-top="{{radiusTop}}"
        radius-bottom="{{radiusBottom}}"
        height="{{height}}"
        radial-segments="{{radialSegments}}"
        height-segments="{{heightSegments}}"
        open-ended="{{openEnded}}"
        theta-start="{{thetaStart}}"
        theta-length="{{thetaLength}}">
      </three-cylinder-geometry>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      is: 'three-cylinder',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeMeshPhongMaterializedMeshBehavior,
        ThreeCylinderGeometryBehavior
      ],
      properties: {
        castShadow: {
          type: Boolean,
          value: true
        },
        receiveShadow: {
          type: Boolean,
          value: true
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-plane">
  <template>
    <three-mesh
      name="{{name}}"
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      cast-shadow="{{castShadow}}"
      receive-shadow="{{receiveShadow}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blend-src="{{blendSrc}}"
        blend-dst="{{blendDst}}"
        blend-equation="{{blendEquation}}"
        depth-test="{{depthTest}}"
        depth-write="{{depthWrite}}"
        polygon-offset="{{polygonOffset}}"
        polygon-offset-factor="{{polygonOffsetFactor}}"
        polygon-offset-units="{{polygonOffsetUnits}}"
        alpha-test="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bump-map="{{bumpMap}}"
        bump-scale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <three-plane-geometry
        width="{{width}}"
        height="{{height}}"
        width-segments="{{widthSegments}}"
        height-segments="{{heightSegments}}">
      </three-plane-geometry>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      is: 'three-plane',
      behaviors: [
        ThreeObjectBehavior, 
        ThreeObject3dBehavior,
        ThreeMeshPhongMaterializedMeshBehavior,
        ThreePlaneGeometryBehavior
      ],
      properties: {
        castShadow: {
          type: Boolean,
          value: true
        },
        receiveShadow: {
          type: Boolean,
          value: true
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-torus">
  <template>
    <three-mesh
      name="{{name}}"
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      cast-shadow="{{castShadow}}"
      receive-shadow="{{receiveShadow}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blend-src="{{blendSrc}}"
        blend-dst="{{blendDst}}"
        blend-equation="{{blendEquation}}"
        depth-test="{{depthTest}}"
        depth-write="{{depthWrite}}"
        polygon-offset="{{polygonOffset}}"
        polygon-offset-factor="{{polygonOffsetFactor}}"
        polygon-offset-units="{{polygonOffsetUnits}}"
        alpha-test="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bump-map="{{bumpMap}}"
        bump-scale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <three-torus-geometry
        radius="{{radius}}"
        tube="{{tube}}"
        radial-segments="{{radialSegments}}"
        tubular-segments="{{tubularSegments}}"
        arc="{{arc}}">
      </three-torus-geometry>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      is: 'three-torus',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior,
        ThreeMeshPhongMaterializedMeshBehavior,
        ThreeTorusGeometryBehavior
      ],
      properties: {
        castShadow: {
          type: Boolean,
          value: true
        },
        receiveShadow: {
          type: Boolean,
          value: true
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-controls">
  <script>
    Polymer({
      is: 'three-controls',
      behaviors: [ThreeObjectBehavior],
      properties: {
        type: {
          type: String,
          value: 'orbit'
        },
        controls: Object,
        center: {
          type: String,
          value: '0,0,0'
        },
        movementSpeed: {
          type: Number,
          value: 1.0
        },
        rollSpeed: {
          type: Number,
          value: 0.005
        },
        lookSpeed: {
          type: Number,
          value: 0.005
        },
        lon: {
          type: Number,
          value: 0
        },
        noFly: {
          type: Boolean,
          value: false
        }
      },
      attached: function() {
        var engineElement = this.getParentThreeNode('three-engine');
        engineElement.controlsElement = this;
      },
      getControls: function(camera, canvas) {
        if (this.type === 'orbit') {
          this.controls = new THREE.OrbitControls(camera, canvas);
          this.controls.target.copy(this._vector3(this.center));
        }
        else if (this.type === 'fly') {
          this.controls = new THREE.FlyControls(camera, canvas);
          this.controls.movementSpeed = this.movementSpeed;
          this.controls.rollSpeed = this.rollSpeed;
        }
        else if (this.type === 'firstperson') {
          this.controls = new THREE.FirstPersonControls(camera, canvas);
          this.controls.movementSpeed = this.movementSpeed;
          this.controls.lookSpeed = this.lookSpeed;
          this.controls.lon = this.lon;
          this.controls.noFly = this.noFly;
        }
        else {
          throw 'Unknown controls type: ' + this.type;
        }
        return this.controls;
      }
    });
  </script>
</dom-module>

<dom-module id="three-loader-mesh">
  <script>
    Polymer({
      is: 'three-loader-mesh',
      behaviors: [
        ThreeObjectBehavior,
        ThreeObject3dBehavior
      ],
      properties: {
        type: {
          type: String,
          value: 'json'
        },
        src: String,
        mesh: Object
      },
      attached: function() {
        this.mesh = new THREE.Mesh();
        if (this.type === 'json') {
          var loader = new THREE.JSONLoader(); 
          loader.load(this.src, function(geometry, materials) {
            this.mesh.geometry = geometry;
            this.mesh.material = materials[0];
            this.mesh.material.ambient = this.mesh.material.color;
          }.bind(this));
        }
        else if (this.type === 'obj') {
          var loader = new THREE.OBJLoader();
          loader.load(this.src, function(object) {
            object.children.forEach(function(child) {
              this.mesh.children.push(child);
            }.bind(this));
          }.bind(this));
        }

        var sceneElement = this.getParentThreeNode('three-scene');
        sceneElement.getScene().add(this.mesh);
      }
    });
  </script>
</dom-module>

<!-- for shader -->
<dom-module id="three-shader-material">
  <script>
    Polymer({
      is: 'three-shader-material',
      behaviors: [
        ThreeObjectBehavior,
        ThreeShaderVariablesContainerBehavior
      ],
      properties: {
        shading: {
          type: Number,
          value: THREE.SmoothShading
        },
        linewidth: {
          type: Number,
          value: 1
        },
        wireframe: {
          type: Boolean,
          value: false
        },
        wireframeLinewidth: {
          type: Number,
          value: 1
        },
        fog: {
          type: Boolean,
          value: false
        },
        lights: {
          type: Boolean,
          value: false
        },
        vertexColors: {
          type: Number,
          value: THREE.NoColors
        },
        skinning: {
          type: Boolean,
          value: false
        },
        material: Object,
        vertexShaderElement: {
          type: Object,
          observer: '_vertexShaderElementChanged'
        },
        fragmentShaderElement: {
          type: Object,
          observer: '_fragmentShaderElementChanged'
        }
      },
      attached: function() {
        var meshElement = this.getParentThreeNode('three-mesh');
        if (meshElement) meshElement.materialElement = this;
      },
      getMaterial: function() {
        var shaderOptions = this.getShaderOptions();
        if (this.vertexShaderElement) {
          shaderOptions['vertexShader'] = this.vertexShaderElement.vertexShader;
        }
        if (this.fragmentShaderElement) {
          shaderOptions['fragmentShader'] = this.fragmentShaderElement.fragmentShader;
        }
        this.material = new THREE.ShaderMaterial(shaderOptions);
        return this.material;
      },
      addUniformsElement: function(element) {
        this.uniformsElements.push(element);
        this.resetMaterial();
      },
      addAttributesElement: function(element) {
        this.attributesElements.push(element);
        this.resetMaterial();
      },
      resetMaterial: function() {
        var meshElement = this.getParentThreeNode('three-mesh');
        if (!meshElement) return;
        meshElement.materialElement = this;
        meshElement.createMesh();

        if (!meshElement.mesh) return;
        meshElement.mesh.material.dispose();
        meshElement.mesh.material = this.getMaterial();
        meshElement.mesh.material.needsUpdate = true;
      },
      _vertexShaderElementChanged: function(newVal, oldVal) {
        this.resetMaterial();
      },
      _fragmentShaderElementChanged: function(newVal, oldVal) {
        this.resetMaterial();
      }
    });
  </script>
</dom-module>

<dom-module id="three-vertex-shader">
  <script>
    Polymer({
      is: 'three-vertex-shader',
      behaviors: [
        ThreeObjectBehavior,
        ThreeShaderBehavior
      ],
      properties: {
        vertexShader: String
      },
      attached: function() {
        this.vertexShader = this.textContent;
        this.textContent = '';
        var materialElement = this.getParentThreeNode('three-shader-material');
        materialElement.vertexShaderElement = this;
      }
    });
  </script>
</dom-module>

<dom-module id="three-fragment-shader">
  <script>
    Polymer({
      is: 'three-fragment-shader',
      behaviors: [
        ThreeObjectBehavior,
        ThreeShaderBehavior
      ],
      properties: {
        fragmentShader: String
      },
      attached: function() {
        this.fragmentShader = this.textContent;
        this.textContent = '';
        var materialElement = this.getParentThreeNode('three-shader-material');
        materialElement.fragmentShaderElement = this;
      }
    });
  </script>
</dom-module>

<dom-module id="three-shader-attributes">
  <script>
    Polymer({
      is: 'three-shader-attributes',
      behaviors: [
        ThreeObjectBehavior,
        ThreeShaderVariableContainerBehavior
      ],
      attached: function() {
        var containerElement = this.getParentThreeNode(['three-shader', 'three-shader-material']);
        if (containerElement) {
          containerElement.addAttributesElement(this);
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-shader-uniforms">
  <script>
    Polymer({
      is: 'three-shader-uniforms',
      behaviors: [
        ThreeObjectBehavior,
        ThreeShaderVariableContainerBehavior
      ],
      attached: function() {
        var containerElement = this.getParentThreeNode(['three-shader', 'three-shader-material']);
        if (containerElement) {
          containerElement.addUniformsElement(this);
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-shader-variable">
  <template></template>
  <script>
    Polymer({
      is: 'three-shader-variable',
      behaviors: [
        ThreeObjectBehavior
      ],
      properties: {
        name: String,
        type: String,
        value: String
      },
      attached: function() {
        var containerElement = this.getParentThreeNode(['three-shader-uniforms', 'three-shader-attributes']);
        containerElement.addVariable(this.name, {type:this.type, value:eval(this.value)}, this.textContent);
      }
    });
  </script>
</dom-module>

<!-- for shader pass -->
<dom-module id="three-shader-pass">
  <script>
    Polymer({
      is: 'three-shader-pass',
      behaviors: [
        ThreeObjectBehavior
      ],
      properties: {
        shaderElements: {
          type: Array,
          value: function() { return []; }
        },
        shaderPass: {
          type: Array,
          value: function() { return []; }
        }
      },
      attached: function() {
        var rendererElement = this.getParentThreeNode('three-renderer');
        rendererElement.shaderPassElement = this;
      },
      addShaderElement: function(element) {
        this.shaderElements.push(element);
      },
      getShaderPass: function() {
        return this.shaderElements.map(function(element) {
          return element.getEffect();
        });
      }
    });
  </script>
</dom-module>

<dom-module id="three-shader">
  <script>
    Polymer({
      is: 'three-shader',
      behaviors: [
        ThreeObjectBehavior,
        ThreeShaderVariablesContainerBehavior
      ],
      properties: {
        type: String,
        renderToScreen: {
          type: Boolean,
          value: false
        },
        effect: Object
      },
      attached: function() {
        var shaderPassElement = this.getParentThreeNode('three-shader-pass');
        shaderPassElement.addShaderElement(this);
      },
      addUniformsElement: function(element) {
        this.uniformsElements.push(element);
      },
      addAttributesElement: function(element) {
        this.attributesElements.push(element);
      },
      getEffect: function() {
        if (!this.effect) {
          this.effect = new THREE.ShaderPass(eval(this.type)); // TODO
          this.effect.renderToScreen = this.renderToScreen;
          shaderOptions = this.getShaderOptions();
          for (var k in shaderOptions['uniforms']) {
            this.effect['uniforms'][k] = shaderOptions['uniforms'][k];
          }
        }
        return this.effect;
      }
    });
  </script>
</dom-module>
