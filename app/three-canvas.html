<link rel="import" href="bower_components/polymer/polymer.html">

<script src="bower_components/threejs/build/three.js"></script>

<!-- controls -->
<script src="bower_components/three.js-controls/src/FirstPersonControls.js"></script>
<script src="bower_components/three.js-controls/src/FlyControls.js"></script>
<script src="bower_components/three.js-controls/src/OrbitControls.js"></script>

<!-- loaders -->
<script src="vendors/three.js/examples/js/loaders/OBJLoader.js"></script>

<!-- postprocess -->
<script src="vendors/three.js/examples/js/shaders/CopyShader.js"></script>
<script src="vendors/three.js/examples/js/shaders/DotScreenShader.js"></script>
<script src="vendors/three.js/examples/js/shaders/RGBShiftShader.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/EffectComposer.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/MaskPass.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/RenderPass.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/ShaderPass.js"></script>

<!-- utils -->
<script>
  THREE.Element = THREE.Element || {Utils:{}};
  THREE.Element.Utils.vector3 = function(val) {
    if (typeof val === 'undefined') {
      return new THREE.Vector3();
    }
    else if (val instanceof THREE.Vector3) {
      return val;
    }
    else if (typeof val === 'string') { // ex) 1,2,3
      try {
        var vals = eval('[' + val + ']');
        return new THREE.Vector3(vals[0], vals[1], vals[2]);
      }
      catch (e) {
        console.log('invalid args: ' + val);
        throw e;
      }
    }
    else {
      console.log('invalid argument: ', val);
      throw 'invalid argument: ' + val;
    }
  };
  THREE.Element.Utils.euler = function(val) {
    if (typeof val === 'undefined') {
      return new THREE.Euler();
    }
    else if (val instanceof THREE.Euler) {
      return val;
    }
    else if (typeof val === 'string') { // ex) 1,2,3
      try {
        var vals = eval('[' + val + ']');
        return new THREE.Euler(vals[0], vals[1], vals[2], vals[3]);
      }
      catch (e) {
        console.log('invalid args: ' + val);
        throw e;
      }
    }
    else {
      console.log('invalid argument: ', val);
      throw 'invalid argument: ' + val;
    }
  };
  THREE.Element.Utils.constant = function(val) {
    if (typeof val === 'string' && /^THREE\./.test(val)) {
      var parts = val.split('.');
      parts.shift();
      var value = THREE;
      while (parts.length !== 0) {
        value = value[parts.shift()];
      }
      return value;
    }
    else {
      return val;
    }
  };
  THREE.Element.Utils.replaceNodeName = function(oldElement, newElementName) {
    var newElement = document.createElement(newElementName);
    oldElement['addEventListener'] = function(eventName, handelr) {
      newElement.addEventListener(eventName, handelr);
    };
    Array.apply(null, oldElement.attributes).forEach(function(attr) {
      newElement.setAttribute(attr.name, attr.value);
    });
    Array.apply(null, oldElement.children).forEach(function(child) {
      newElement.appendChild(child);
    });
    if (oldElement.parentNode) {
      oldElement.parentNode.insertBefore(newElement, oldElement); 
      oldElement.parentNode.removeChild(oldElement);
    }
  };
</script>

<!-- behaviors -->
<script>
  ThreeObjectBehavior = {
    properties: {
      object: Object,
      isThreeObject: {
        type: Boolean,
        value: true,
        readOnly: true
      }
    },
    getParentThreeNode: function(localName) {
      localName = localName || 'three-engine';
      var cursor = this.parentNode;
      while (cursor.localName !== 'body') {
        if (cursor.localName === localName) return cursor;
        cursor = cursor.parentNode;
      }
      return null;
    },
    _vector3: function(val) {
      return THREE.Element.Utils.vector3(val);
    },
    _euler: function(val) {
      return THREE.Element.Utils.euler(val);
    }
  };
  ThreeObject3dBehavior = {
    properties: {
      name: {
        type: String
      },
      position: {
        type: String,
        value: '0,0,0',
        reflectToAttribute: true,
        notify: true
      },
      rotation: {
        type: String,
        value: '0,0,0',
        reflectToAttribute: true,
        notify: true
      },
      scale: {
        type: String,
        value: '1,1,1',
        reflectToAttribute: true,
        notify: true
      },
      castShadow: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      receiveShadow: {
        type: Boolean,
        value: false,
        readOnly: true
      }
    },
    _positionChanged: function(newVal, oldVal) {
      this.position = this._vector3(newVal);
      if (typeof this.object !== 'undefined') {
        this.object.position.copy(this.position);
      }
    },
    _rotationChanged: function(newVal, oldVal) {
      this.rotation = this._euler(newVal);
      if (typeof this.object !== 'undefined') {
        this.object.rotation.copy(this.rotation);
      }
    },
    _scaleChanged: function(newVal, oldVal) {
      this.scale = this._vector3(newVal);
      if (typeof this.object !== 'undefined') {
        this.object.scale.copy(this.scale);
      }
    }
  };
  ThreeLightBehavior = {
    properties: {
      light: Object,
      color: {
        type: String,
        value: '#ffffff'
      }
    }
  };
  ThreeMaterialBehavior = {
    properties: {
      side: {
        type: Number,
        value: THREE.FrontSide
      },
      opacity: {
        type: Number,
        value: 1
      },
      transparent: {
        type: Number,
        value: false
      },
      blending: {
        type: Number,
        value: THREE.NormalBlending
      },
      blendSrc: {
        type: Number,
        value: THREE.SrcAlphaFactor
      },
      blendDst: {
        type: Number,
        value: THREE.OneMinusSrcAlphaFactor
      },
      blendEquation: {
        type: Number,
        value: THREE.AddEquation
      },
      depthTest: {
        type: Boolean,
        value: true
      },
      depthWrite: {
        type: Boolean,
        value: true
      },
      polygonOffset: {
        type: Boolean,
        value: false
      },
      polygonOffsetFactor: {
        type: Number,
        value: 0
      },
      polygonOffsetUnits: {
        type: Number,
        value: 0
      },
      alphaTest: {
        type: Number,
        value: 0
      },
      overdraw: {
        type: Number,
        value: 0
      },
      visible: {
        type: Boolean,
        value: true
      }
    },
    _getOptions: function() {
      if (this.opacity < 1) this.transparent = true;
      return {
        side: this.side,
        opacity: this.opacity,
        transparent: this.transparent,
        blending: this.blending,
        blendSrc: this.blendSrc,
        blendDst: this.blendDst,
        blendEquation: this.blendEquation,
        depthTest: this.depthTest,
        depthWrite: this.depthWrite,
        polygonOffset: this.polygonOffset,
        polygonOffsetFactor: this.polygonOffsetFactor,
        polygonOffsetUnits: this.polygonOffsetUnits,
        alphaTest: this.alphaTest,
        overdraw: this.overdraw,
        visible: this.visible
      };
    }
  };
  ThreeMeshPhongMaterializedMeshBehavior = {
    properties: {
/*
      side: {
        type: Number,
        value: 0
      },
      opacity: {
        type: Number,
        value: 0
      },
      transparent: {
        type: Number,
        value: 0
      },
      blending: {
        type: Number,
        value: 0
      },
      blendSrc: {
        type: Number,
        value: 0
      },
      blendDst: {
        type: Number,
        value: 0
      },
      blendEquation: {
        type: Number,
        value: 0
      },
      depthTest: {
        type: Number,
        value: 0
      },
      depthWrite: {
        type: Number,
        value: 0
      },
      polygonOffset: {
        type: Number,
        value: 0
      },
      polygonOffsetFactor: {
        type: Number,
        value: 0
      },
      polygonOffsetUnits: {
        type: Number,
        value: 0
      },
      alphaTest: {
        type: Number,
        value: 0
      },
      overdraw: {
        type: Number,
        value: 0
      },
      visible: {
        type: Number,
        value: 0
      },
*/
      color: {
        type: String
      },
/*
      ambient: {
        type: Number,
        value: 0
      },
      emissive: {
        type: Number,
        value: 0
      },
      specular: {
        type: Number,
        value: 0
      },
      shininess: {
        type: Number,
        value: 0
      },
      metal: {
        type: Number,
        value: 0
      },
*/
      map: {
        type: String
      },
/*
      bumpMap: {
        type: Number,
        value: 0
      },
      bumpScale: {
        type: Number,
        value: 0
      },
      fog: {
        type: Number,
        value: 0
      },
      shading: {
        type: Number,
        value: 0
      },
      wireframe: {
        type: Number,
        value: 0
      }
*/
    }
  };
</script>

<!-- components -->
<dom-module id="three-engine">
  <script>
    Polymer({
      is: 'three-engine',
      behaviors: [ThreeObjectBehavior],
      properties: {
        fullscreen: {
          type: Boolean,
          value: false
        },
        width: {
          type: Number,
          value: 0
        },
        height: {
          type: Number,
          value: 0
        },
        canvas: String,
        canvasElement: Object,
        renderer: Object,
        scene: Object,
        camera: Object,
        controls: Object,
        rendererElement: {
          type: Object,
          observer: '_rendererElementChanged'
        },
        sceneElement: {
          type: Object,
          observer: '_sceneElementChanged'
        },
        cameraElement: {
          type: Object,
          observer: '_cameraElementChanged'
        },
        controlsElement: {
          type: Object,
          observer: '_controlsElementChanged'
        }
      },
      render: function() {
        if (this.composer) {
          this.composer.render();
        }
        else {
          if (!this.renderer) throw 'no renderer';
          if (!this.scene) throw 'no scene';
          if (!this.camera) throw 'no camera';
          this.renderer.render(this.scene, this.camera);
        }
      },
      start: function() {
        var canvasElement = this.getParentThreeNode('three-canvas');
        if (canvasElement) {
          canvasElement.renderer = this.renderer;
          canvasElement.scene = this.scene;
          canvasElement.camera = this.camera;
        }
        if (this.fullscreen) {
          window.addEventListener('resize', function() {
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
          }.bind(this), false);
        }

        var clock = new THREE.Clock();
        ((function animate() {
          try {
            this.render();
            this.fire('render');
            if (this.controls) this.controls.update(clock.getDelta());
            requestAnimationFrame(animate.bind(this));
          }
          catch (e) {
            console.log(e);
          }
        }).bind(this))();
        if (!this.controls && this.controlsElement) {
          this.controls = this.controlsElement.getControls(this.camera, this.canvasElement);
        }
      },
      _setupCanvas: function() {
        if (this.canvas) {
          this.canvasElement = document.getElementById(this.canvas);
        }
        else if (this.previousElementSibling && this.previousElementSibling.tagName === 'CANVAS') {
          this.canvasElement = this.previousElementSibling;
        }
        else {
          if (this.width === 0 || this.height === 0) {
            if (this.fullscreen) {
              this.width = window.innerWidth;
              this.height = window.innerHeight;
            }
            else {
              throw 'no canvas';
            }
          }
          this.canvasElement = document.createElement('canvas');
          this.canvasElement.width = this.width;
          this.canvasElement.height = this.height;
          if (this.fullscreen) {
            this.canvasElement.style.margin = 0;
            this.canvasElement.style.padding = 0;
            this.canvasElement.style.position = 'absolute';
            this.canvasElement.style.top = 0;
            this.canvasElement.style.left = 0;
          }
          this.parentNode.insertBefore(this.canvasElement, this);
        }
      },
      getCanvas: function() {
        if (!this.canvasElement) this._setupCanvas();
        return this.canvasElement;
      },
      _rendererElementChanged: function(newValue, oldValue) {
        this.renderer = this.rendererElement.getRenderer(this);

        if (this.sceneElement && this.cameraElement) this.start();
      },
      _sceneElementChanged: function(newValue, oldValue) {
        this.scene = this.sceneElement.getScene();

        if (this.rendererElement && this.cameraElement) this.start();
      },
      _cameraElementChanged: function(newValue, oldValue) {
        this.camera = this.cameraElement.getCamera();

        if (this.rendererElement && this.sceneElement) this.start();
      },
      _controlsElementChanged: function(newValue, oldValue) {
        if (!this.controls && this.camera && this.canvasElement) {
          this.controls = this.controlsElement.getControls(this.camera, this.canvasElement);
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-renderer">
  <script>
    Polymer({
      is: 'three-renderer',
      behaviors: [ThreeObjectBehavior],
      attached: function() {
        var engineElement = this.getParentThreeNode('three-engine');
        if (engineElement) {
          engineElement.rendererElement = this;
        }
      },
      getRenderer: function(engineElement) {
        if (this.renderer) return this.renderer;

        this.renderer = new THREE.WebGLRenderer({
          canvas: engineElement.getCanvas()
        });
        return this.renderer;
      }
    });
  </script>
</dom-module>

<dom-module id="three-scene">
  <script>
    Polymer({
      is: 'three-scene',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        scene: Object
      },
      created: function() {
        this.scene = new THREE.Scene();
      },
      attached: function() {
        var engineElement = this.getParentThreeNode('three-engine');
        if (engineElement) {
          engineElement.sceneElement = this;
        }
      },
      getScene: function() {
        return this.scene;
      }
    });
  </script>
</dom-module>

<dom-module id="three-camera">
  <script>
    Polymer({
      is: 'three-camera',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        type: {
          type: String,
          value: 'perspective'
        }
      },
      ready: function() {
        THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-camera');
      }
    });
  </script>
</dom-module>

<dom-module id="three-perspective-camera">
  <script>
    Polymer({
      is: 'three-perspective-camera',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        lookAt: {
          type: String,
          observer: '_lookAtChanged'
        },
        controls: String
      },
      attached: function() {
        var engineElement = this.getParentThreeNode('three-engine');
        var canvas = engineElement.getCanvas();

        var aspect = canvas.width / canvas.height;
        this.camera = new THREE.PerspectiveCamera(15, aspect);
        this.camera.userData['element'] = this;
        this.camera.position.copy(this._vector3(this.position));
        this.camera.lookAt(this._vector3(this.lookAt));
        this.object = this.camera;

        if (this.controls === 'orbit') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'orbit');
          controlsElm.setAttribute('center', this.lookAt);
          this.appendChild(controlsElm);
        }
        else if (this.controls === 'fly') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'fly');
          this.appendChild(controlsElm);
        }
        else if (this.controls === 'firstperson') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'firstperson');
          this.appendChild(controlsElm);
        }

        var sceneElement = this.getParentThreeNode('three-scene');
        sceneElement.getScene().add(this.camera);

        engineElement.cameraElement = this;
      },
      getCamera: function() {
        return this.camera;
      },
      _lookAtChanged: function(newVal, oldVal) {
        if (typeof this.camera !== 'undefined') {
          this.camera.lookAt(this.vector3(newVal));
        }
      }
    });
  </script>
</dom-module>

<dom-module id="three-light">
  <script>
    Polymer({
      is: 'three-light',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        type: {
          type: String,
          value: 'directional'
        },
        color: {
          type: String,
          value: '#ffffff'
        }
      },
      ready: function() {
        THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-light');
      }
    });
  </script>
</dom-module>

<dom-module id="three-directional-light">
  <script>
    Polymer({
      is: 'three-directional-light',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeLightBehavior],
      properties: {
        type: {
          type: String,
          value: 'directional'
        },
        intensity: {
          type: Number,
          value: 1
        },
        castShadow: {
          type: Boolean,
          value: false
        },
        onlyShadow: {
          type: Boolean,
          value: false
        },
        shadowCameraNear: {
          type: Number,
          value: 50
        },
        shadowCameraFar: {
          type: Number,
          value: 5000
        },
        shadowCameraLeft: {
          type: Number,
          value: -500
        },
        shadowCameraRight: {
          type: Number,
          value: 500
        },
        shadowCameraTop: {
          type: Number,
          value: 500
        },
        shadowCameraBottom: {
          type: Number,
          value: -500
        },
        shadowCameraVisible: {
          type: Boolean,
          value: false
        },
        shadowBias: {
          type: Number,
          value: 0
        },
        shadowDarkness: {
          type: Number,
          value: 0.5
        },
        shadowMapWidth: {
          type: Number,
          value: 512
        },
        shadowMapHeight: {
          type: Number,
          value: 512
        }
      },
      attached: function() {
        this.light = new THREE.DirectionalLight(new THREE.Color(this.color));
        this.light.position.copy(this._vector3(this.position));
        this.light.shadowMapWidth = this.shadowMapWidth;
        this.light.shadowMapHeight = this.shadowMapHeight;

        var sceneElement = this.getParentThreeNode('three-scene');
        sceneElement.getScene().add(this.light);
      }
    });
  </script>
</dom-module>

<dom-module id="three-ambient-light">
  <script>
    Polymer({
      is: 'three-ambient-light',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeLightBehavior],
      attached: function() {
        this.light = new THREE.AmbientLight(new THREE.Color(this.color));

        var sceneElement = this.getParentThreeNode('three-scene');
        sceneElement.getScene().add(this.light);
      }
    });
  </script>
</dom-module>

<dom-module id="three-mesh">
  <script>
    Polymer({
      is: 'three-mesh',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        materialElement: {
          type: Object,
          observer: '_materialElementChanged'
        },
        geometryElement: {
          type: Object,
          observer: '_geometryElementChanged'
        },
        material: Object,
        geometry: Object,
        mesh: Object
      },
      _materialElementChanged: function(newVal, oldVal) {
        this.material = this.materialElement.getMaterial();
        if (this.geometry) this._createMesh();
      },
      _geometryElementChanged: function(newVal, oldVal) {
        this.geometry = this.geometryElement.getGeometry();
        if (this.material) this._createMesh();
      },
      _createMesh: function() {
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.position.copy(this._vector3(this.position));
        this.mesh.rotation.copy(this._euler(this.rotation));
        this.mesh.scale.copy(this._vector3(this.scale));
        if (this.name) this.mesh.name = this.name;

        var sceneElement = this.getParentThreeNode('three-scene');
        sceneElement.getScene().add(this.mesh);
      }
    });
  </script>
</dom-module>

<dom-module id="three-material">
  <script>
    Polymer({
      is: 'three-material',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeMaterialBehavior],
      properties: {
        type: {
          type: String,
          value: 'mesh-phong'
        }
      },
      ready: function() {
        THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-material');
      },
    });
  </script>
</dom-module>

<dom-module id="three-mesh-phong-material">
  <script>
    Polymer({
      is: 'three-mesh-phong-material',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeMaterialBehavior],
      properties: {
        color: {
          type: String,
          value: '#ffffff'
        },
        ambient: {
          type: String,
          value: '#ffffff'
        },
        emissive: {
          type: String,
          value: '#000000'
        },
        specular: {
          type: String,
          value: '#000000'
        },
        shininess: {
          type: Number,
          value: 30
        },
        metal: {
          type: Boolean,
          value: false
        },
        map: {
          type: String,
          value: ''
        },
        bumpMap: {
          type: String,
          value: ''
        },
        bumpScale: {
          type: Number,
          value: 1
        },
        fog: {
          type: Boolean,
          value: true
        },
        shading: {
          type: Number,
          value: THREE.SmoothShading
        },
        wireframe: {
          type: Boolean,
          value: false
        }
      },
      attached: function() {
        this.material = new THREE.MeshPhongMaterial(this._getOptions());
        if (this.map !== '') {
          this.material.map = THREE.ImageUtils.loadTexture(this.map);
        }
        if (this.bumpMap !== '') {
          this.material.bumpMap = THREE.ImageUtils.loadTexture(this.bumpMap);
        }

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.materialElement = this;
      },
      getMaterial: function() {
        return this.material;
      },
      _getOptions: function() {
        var opts = ThreeMaterialBehavior._getOptions.call(this);
        opts['color'] = new THREE.Color(this.color);
        opts['ambient'] = new THREE.Color(this.ambient);
        opts['emissive'] = new THREE.Color(this.emissive);
        opts['specular'] = new THREE.Color(this.specular);
        opts['shininess'] = this.shininess;
        opts['metal'] = this.metal;
        opts['bumpScale'] = this.bumpScale;
        opts['fog'] = this.fog;
        opts['shading'] = this.shading;
        opts['wireframe'] = this.wireframe;
        return opts;
      }
    });
  </script>
</dom-module>

<dom-module id="three-sphere-geometry">
  <script>
    Polymer({
      is: 'three-sphere-geometry',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        radius: {
          type: Number,
          value: 50
        },
        widthSegments: {
          type: Number,
          value: 32
        },
        heightSegments: {
          type: Number,
          value: 16
        },
        phiStart: {
          type: Number,
          value: 0
        },
        phiLength: {
          type: Number,
          value: Math.PI * 2
        },
        thetaStart: {
          type: Number,
          value: 0
        },
        thetaLength: {
          type: Number,
          value: Math.PI
        }
      },
      attached: function() {
        this.geometry = new THREE.SphereGeometry(this.radius, this.widthSegments, this.heightSegments, this.phiStart, this.phiLength, this.thetaStart, this.thetaLength);

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.geometryElement = this;
      },
      getGeometry: function() {
        return this.geometry;
      }
    });
  </script>
</dom-module>

<dom-module id="three-box-geometry">
  <script>
    Polymer({
      is: 'three-box-geometry',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior],
      properties: {
        width: {
          type: Number,
          value: 1 
        },
        height: {
          type: Number,
          value: 1 
        },
        depth: {
          type: Number,
          value: 1 
        },
        widthSegments: {
          type: Number,
          value: 1 
        },
        heightSegments: {
          type: Number,
          value: 1
        },
        depthSegments: {
          type: Number,
          value: 1
        }
      },
      attached: function() {
        this.geometry = new THREE.BoxGeometry(this.width, this.height, this.depth, this.widthSegments, this.heightSegments, this.depthSegments);

        var meshElement = this.getParentThreeNode('three-mesh');
        meshElement.geometryElement = this;
      },
      getGeometry: function() {
        return this.geometry;
      }
    });
  </script>
</dom-module>

<dom-module id="three-canvas">
  <template>
    <three-engine fullscreen="{{fullscreen}}" width$="{{width}}" height$="{{height}}" shadow-enabled="{{shadowEnabled}}">
      <three-renderer antialias="{{antialias}}" clear-color$="{{clearColor}}">
        <content select="three-shader-pass"></content>
      </three-renderer>
      <three-scene id="scene">
        <content></content>
      </three-scene>
    </three-engine>
  </template>
  <script>
    Polymer({
      is: 'three-canvas',
      behaviors: [ThreeObjectBehavior],
      properties: {
        width: Number,
        height: Number,
        antialias: {
          type: Boolean,
          value: true
        },
        clearColor: String,
        fullscreen: {
          type: Boolean,
          value: false
        },
        defaultLight: {
          type: Boolean,
          value: false
        },
        shadowEnabled: {
          type: Boolean,
          value: false
        },
        renderer: Object,
        scene: Object,
        camera: Object
      },
      ready: function() {
        if (this.defaultLight) {
          /*
          <template is="dom-if" if="{{defaultLight}}">
            <three-directional-light position="0.577,0.577,0.577" color="#cccccc"></three-directional-light>
            <three-ambient-light color="#333333"></three-ambient-light>
          </template>
          */
          var directionalLight = document.createElement('three-directional-light');
          //directionalLight.setAttribute('position', '0.577,0.577,0.577');
          directionalLight.setAttribute('position', '100,100,100');
          directionalLight.setAttribute('color', '#cccccc');
          this.$.scene.appendChild(directionalLight);
          var ambientLight = document.createElement('three-ambient-light');
          ambientLight.setAttribute('color', '#333333');
          this.$.scene.appendChild(ambientLight);
        }
      },
      getObjectByName: function(name) {
        return this.scene.getObjectByName(name);
      }
    });
  </script>
</dom-module>

<dom-module id="three-sphere">
  <template>
    <three-mesh name="{{name}}" position="{{position}}" rotation="{{rotation}}" scale="{{scale}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blend-src="{{blendSrc}}"
        blend-dst="{{blendDst}}"
        blend-equation="{{blendEquation}}"
        depth-test="{{depthTest}}"
        depth-write="{{depthWrite}}"
        polygon-offset="{{polygonOffset}}"
        polygon-offset-factor="{{polygonOffsetFactor}}"
        polygon-offset-units="{{polygonOffsetUnits}}"
        alpha-test="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bump-map="{{bumpMap}}"
        bump-scale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <three-sphere-geometry
        radius="{{radius}}"
        width-segments="{{widthSegments}}"
        height-segments="{{heightSegments}}"
        phi-start="{{phiStart}}"
        phi-length="{{phiLength}}"
        theta-start="{{thetaStart}}"
        theta-length="{{thetaLength}}">
      </three-sphere-geometry>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      is: 'three-sphere',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeMeshPhongMaterializedMeshBehavior]
    });
  </script>
</dom-module>

<dom-module id="three-box">
  <template>
    <three-mesh name="{{name}}" position="{{position}}" rotation="{{rotation}}" scale="{{scale}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blend-src="{{blendSrc}}"
        blend-dst="{{blendDst}}"
        blend-equation="{{blendEquation}}"
        depth-test="{{depthTest}}"
        depth-write="{{depthWrite}}"
        polygon-offset="{{polygonOffset}}"
        polygon-offset-factor="{{polygonOffsetFactor}}"
        polygon-offset-units="{{polygonOffsetUnits}}"
        alpha-test="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bump-map="{{bumpMap}}"
        bump-scale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <three-box-geometry
        width="{{width}}"
        height="{{height}}"
        depth="{{depth}}"
        width-segments="{{widthSegments}}"
        height-segments="{{heightSegments}}"
        depth-segments="{{depthSegments}}">
      </three-box-geometry>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      is: 'three-box',
      behaviors: [ThreeObjectBehavior, ThreeObject3dBehavior, ThreeMeshPhongMaterializedMeshBehavior]
    });
  </script>
</dom-module>

<dom-module id="three-controls">
  <script>
    Polymer({
      is: 'three-controls',
      behaviors: [ThreeObjectBehavior],
      properties: {
        type: {
          type: String,
          value: 'orbit'
        },
        controls: Object,
        center: {
          type: String,
          value: '0,0,0'
        },
        movementSpeed: {
          type: Number,
          value: 1.0
        },
        rollSpeed: {
          type: Number,
          value: 0.005
        },
        lookSpeed: {
          type: Number,
          value: 0.005
        },
        lon: {
          type: Number,
          value: 0
        },
        noFly: {
          type: Boolean,
          value: false
        }
      },
      attached: function() {
        var engineElement = this.getParentThreeNode('three-engine');
        engineElement.controlsElement = this;
      },
      getControls: function(camera, canvas) {
        if (this.type === 'orbit') {
          this.controls = new THREE.OrbitControls(camera, canvas);
          this.controls.target.copy(this._vector3(this.center));
        }
        else if (this.type === 'fly') {
          this.controls = new THREE.FlyControls(camera, canvas);
          this.controls.movementSpeed = this.movementSpeed;
          this.controls.rollSpeed = this.rollSpeed;
        }
        else if (this.type === 'firstperson') {
          this.controls = new THREE.FirstPersonControls(camera, canvas);
          this.controls.movementSpeed = this.movementSpeed;
          this.controls.lookSpeed = this.lookSpeed;
          this.controls.lon = this.lon;
          this.controls.noFly = this.noFly;
        }
        else {
          throw 'Unknown controls type: ' + this.type;
        }
        return this.controls;
      }
    });
  </script>
</dom-module>
