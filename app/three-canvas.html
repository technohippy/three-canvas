<link rel="import" href="bower_components/polymer/polymer.html">

<script src="bower_components/threejs/build/three.js"></script>

<!-- controls -->
<script src="bower_components/three.js-controls/src/FirstPersonControls.js"></script>
<script src="bower_components/three.js-controls/src/FlyControls.js"></script>
<script src="bower_components/three.js-controls/src/OrbitControls.js"></script>

<!-- loaders -->
<script src="vendors/three.js/examples/js/loaders/OBJLoader.js"></script>

<!-- postprocess -->
<script src="vendors/three.js/examples/js/postprocessing/EffectComposer.js"></script>
<script src="vendors/three.js/examples/js/shaders/CopyShader.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/MaskPass.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/RenderPass.js"></script>
<script src="vendors/three.js/examples/js/postprocessing/ShaderPass.js"></script>

<script>
  THREE.Element = THREE.Element || {Utils:{}};
  THREE.Element.Utils.vector3 = function(val) {
    if (typeof val === 'undefined') {
      return new THREE.Vector3();
    }
    else if (val instanceof THREE.Vector3) {
      return val;
    }
    else if (typeof val === 'string') { // ex) 1,2,3
      try {
        var vals = eval('[' + val + ']');
        return new THREE.Vector3(vals[0], vals[1], vals[2]);
      }
      catch (e) {
        console.log('invalid args: ' + val);
        throw e;
      }
    }
    else {
      console.log('invalid argument: ', val);
      throw 'invalid argument: ' + val;
    }
  };
  THREE.Element.Utils.euler = function(val) {
    if (typeof val === 'undefined') {
      return new THREE.Euler();
    }
    else if (val instanceof THREE.Euler) {
      return val;
    }
    else if (typeof val === 'string') { // ex) 1,2,3
      try {
        var vals = eval('[' + val + ']');
        return new THREE.Euler(vals[0], vals[1], vals[2], vals[3]);
      }
      catch (e) {
        console.log('invalid args: ' + val);
        throw e;
      }
    }
    else {
      console.log('invalid argument: ', val);
      throw 'invalid argument: ' + val;
    }
  };
  THREE.Element.Utils.constant = function(val) {
    if (typeof val === 'string' && /^THREE\./.test(val)) {
      var parts = val.split('.');
      parts.shift();
      var value = THREE;
      while (parts.length !== 0) {
        value = value[parts.shift()];
      }
      return value;
    }
    else {
      return val;
    }
  };
  THREE.Element.Utils.replaceNodeName = function(oldElement, newElementName) {
    var newElement = document.createElement(newElementName);
    oldElement['addEventListener'] = function(eventName, handelr) {
      newElement.addEventListener(eventName, handelr);
    };
    Array.apply(null, oldElement.attributes).forEach(function(attr) {
      newElement.setAttribute(attr.name, attr.value);
    });
    Array.apply(null, oldElement.children).forEach(function(child) {
      newElement.appendChild(child);
    });
    if (oldElement.parentNode) {
      oldElement.parentNode.insertBefore(newElement, oldElement); 
      oldElement.parentNode.removeChild(oldElement);
    }
  };
</script>

<polymer-element name="three-engine" attributes="canvas,width,height,fullscreen,shadowEnabled">
  <script>
    Polymer({
      fullscreen: false,
      shadowEnabled: false,
      isSetup: false,
      domReady: function() {
        if (typeof this.parentNode.tagName === 'undefined') return; // #shadowroot
        this.setup();
        this.start();
      },
      setup: function() {
        if (this.isSetup) return;
        var isFullscreen = this.fullscreen || this.fullscreen === '';
        if (this.canvas) {
          this.canvas = document.getElementById(this.canvas);
        }
        else if (this.previousElementSibling && this.previousElementSibling.tagName === 'CANVAS') {
          this.canvas = this.previousElementSibling;
        }
        else {
          if (typeof this.width === 'undefined' || typeof this.height === 'undefined') {
            if (isFullscreen) {
              this.width = window.innerWidth;
              this.height = window.innerHeight;
            }
            else {
              throw 'no canvas';
            }
          }
          this.canvas = document.createElement('canvas');
          this.canvas.width = this.width;
          this.canvas.height = this.height;
          if (isFullscreen) {
            this.canvas.style.margin = 0;
            this.canvas.style.padding = 0;
            this.canvas.style.position = 'absolute';
            this.canvas.style.top = 0;
            this.canvas.style.left = 0;
          }
          this.parentNode.insertBefore(this.canvas, this);
        }

        var rendererElm = this.querySelector('three-renderer');
        rendererElm.setup(this);
        this.renderer = rendererElm.renderer;

        var sceneElm = this.querySelector('three-scene');
        sceneElm.setup(this);
        this.scene = sceneElm.scene;

        if (typeof rendererElm.cameraId === 'undefined') {
          this.scene.children.forEach(function(child) {
            if (child instanceof THREE.Camera) {
              this.camera = child;
            }
          }.bind(this));
        }
        else {
          var cameraId = rendererElm.cameraId;
          var cameraElm = sceneElm.querySelector('#' + cameraId);
          cameraElm.setup(this);
          this.camera = cameraElm.camera;
        }
        if (typeof this.camera === 'undefined') throw 'no camera';
        if (typeof this.camera.userData['element'] !== 'undefined') {
          var controlsElm = this.camera.userData['element'].querySelector('three-controls');
          if (controlsElm) {
            controlsElm.setup(this.camera, this.canvas);
            this.controls = controlsElm.controls;
          }
        }
        this.isSetup = true;
      },
      render: function() {
        this.renderer.render(this.scene, this.camera);
      },
      getObjectByName: function(name) {
        return this.scene.getObjectByName(name);
      },
      start: function() {
        if (this.fullscreen || this.fullscreen === '') {
          window.addEventListener('resize', function() {
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
          }.bind(this), false);
        }

        var clock = new THREE.Clock();
        ((function animate() {
          requestAnimationFrame(animate.bind(this));
          this.render();
          this.fire('render');
          if (this.controls) this.controls.update(clock.getDelta());
        }).bind(this))();
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-renderer" attributes="precision,alpha,depth,stencil,antialias,premultipliedAlpha,preserveDrawingBuffer,logarithmicDepthBuffer,clearColor,autoClear,autoClearColor,autoClearDepth,autoClearStencil,sortObjects,gammaInput,gammaOutput,shadowMapEnabled,shadowMapType,shadowMapCullFace,shadowMapDebug,shadowMapCascade,maxMorphTargets,maxMorphNormals,autoScaleCubemaps,,sceneId,cameraId">
  <script>
    Polymer({
      precision: 'highp',
      alpha: false,
      depth: true,
      stencil: true,
      antialias: false,
      premultipliedAlpha: true,
      preserveDrawingBuffer: false,
      logarithmicDepthBuffer: false,
      clearColor: '#000000',
      autoClear: true,
      autoClearColor: true,
      autoClearDepth: true,
      autoClearStencil: true,
      sortObjects: true,
      gammaInput: false,
      gammaOutput: false,
      shadowMapEnabled: false,
      shadowMapType: THREE.PCFShadowMap,
      shadowMapCullFace: THREE.CullFaceFront,
      shadowMapDebug: false,
      shadowMapCascade: false,
      maxMorphTargets: 8,
      maxMorphNormals: 4,
      autoScaleCubemaps: true,
      isSetup: false,
      setup: function(threejs) {
        if (this.isSetup) return;
        this.canvas = threejs.canvas;
        this.renderer = new THREE.WebGLRenderer({
          canvas:this.canvas,
          precision:this.precision,
          alpha:this.alpha,
          depth:this.depth,
          stencil:this.stencil,
          antialias:this.antialias,
          premultipliedAlpha:this.premultipliedAlpha,
          preserveDrawingBuffer:this.preserveDrawingBuffer,
          logarithmicDepthBuffer:this.logarithmicDepthBuffer
        });
        this.renderer.setClearColor(new THREE.Color(this.clearColor), 1);
        this.renderer.autoClear = this.autoClear;
        this.renderer.autoClearColor = this.autoClearColor;
        this.renderer.autoClearDepth = this.autoClearDepth;
        this.renderer.autoClearStencil = this.autoClearStencil;
        this.renderer.sortObjects = this.sortObjects;
        this.renderer.gammaInput = this.gammaInput;
        this.renderer.gammaOutput = this.gammaOutput;
        this.renderer.shadowMapEnabled = this.shadowMapEnabled;
        this.renderer.shadowMapType = this.shadowMapType;
        this.renderer.shadowMapCullFace = this.shadowMapCullFace;
        this.renderer.shadowMapDebug = this.shadowMapDebug;
        this.renderer.shadowMapCascade = this.shadowMapCascade;
        this.renderer.maxMorphTargets = this.maxMorphTargets;
        this.renderer.maxMorphNormals = this.maxMorphNormals;
        this.renderer.autoScaleCubemaps = this.autoScaleCubemaps;
        if (threejs.shadowEnabled) {
          this.renderer.shadowMapEnabled = true;
        }
        this.isSetup = true;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-scene" attributes="">
  <script>
    Polymer({
      isSetup: false,
      setup: function(threejs) {
        if (this.isSetup) return;

        this.scene = new THREE.Scene();

        Array.apply(null, this.children).forEach(function(child) {
          if (child.setup) child.setup(threejs);
          if (child.object) this.scene.add(child.object);
          // TODO: should be refactored
          if (child.getDistributedNodes) {
            Array.apply(null, child.getDistributedNodes()).forEach(function(contentChild) {
              if (contentChild.setup) contentChild.setup(threejs);
              if (contentChild.object) this.scene.add(contentChild.object);
            }, this);
          }
        }, this);

        // TODO: should be refactored
        if (threejs.shadowEnabled) {
          this.scene.children.forEach(function(object3d) {
            if (object3d.type === 'DirectionalLight') {
              object3d.castShadow = true;
            }
            else if (object3d.type === 'Mesh') {
              if (object3d.geometry.type === 'PlaneBufferGeometry' 
                  || object3d.geometry.type === 'PlaneGeometry') {
                object3d.receiveShadow = true;
              }
              else {
                object3d.castShadow = true;
              }
            }
          }, this);
        }

        this.isSetup = true;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-object3d" attributes="name,position,rotation,scale,castShadow,receiveShadow">
  <script>
    Polymer({
      isSetup: false,
      castShadow: false,
      receiveShadow: false,
      scale: '1,1,1',
      setup: function() {
        if (typeof this.object !== 'undefined') {
          this.object.castShadow = this.castShadow;
          this.object.receiveShadow = this.receiveShadow;
          if (typeof this.name !== 'undefined') {
            this.object.name = this.name;
          }
        }
      },
      ready: function() {
        this.position = this.vector3(this.position);
        this.rotation = this.euler(this.rotation);
        this.scale = this.vector3(this.scale);
      },
      vector3: function(val) {
        return THREE.Element.Utils.vector3(val);
      },
      euler: function(val) {
        return THREE.Element.Utils.euler(val);
      },
      positionChanged: function(oldVal, newVal) {
        this.position = this.vector3(newVal);
        if (typeof this.object !== 'undefined') {
          this.object.position.copy(this.position);
        }
      },
      rotationChanged: function(oldVal, newVal) {
        this.rotation = this.euler(newVal);
        if (typeof this.object !== 'undefined') {
          this.object.rotation.copy(this.rotation);
        }
      },
      scaleChanged: function(oldVal, newVal) {
        this.scale = this.vector3(newVal);
        if (typeof this.object !== 'undefined') {
          this.object.scale.copy(this.scale);
        }
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-camera" extends="three-object3d" attributes="type">
  <script>
    Polymer({
      type: 'perspective',
      ready: function() {
        if (this.localName === 'three-camera') {
          THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-camera');
        }
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-perspective-camera" extends="three-camera" attributes="lookAt,controls">
  <script>
    Polymer({
      setup: function(threejs) {
        if (this.isSetup) return;
        var aspect = threejs.canvas.width / threejs.canvas.height;
        this.camera = new THREE.PerspectiveCamera(15, aspect);
        this.camera.userData['element'] = this;
        this.camera.position.copy(this.vector3(this.position));
        this.camera.lookAt(this.vector3(this.lookAt));
        this.object = this.camera;
        this.isSetup = true;

        if (this.controls === 'orbit') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'orbit');
          controlsElm.setAttribute('center', this.lookAt);
          this.appendChild(controlsElm);
        }
        else if (this.controls === 'fly') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'fly');
          this.appendChild(controlsElm);
        }
        else if (this.controls === 'firstperson') {
          var controlsElm = document.createElement('three-controls');
          controlsElm.setAttribute('type', 'firstperson');
          this.appendChild(controlsElm);
        }

        this.super();
      },
      lookAtChanged: function(oldVal, newVal) {
        if (typeof this.camera !== 'undefined') {
          this.camera.lookAt(this.vector3(newVal));
        }
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-canvas" attributes="width,height,antialias,clearColor,fullscreen,defaultLight,shadowEnabled">
  <template>
    <three-engine fullscreen={{fullscreen}} width="{{width}}" height="{{height}}" shadowEnabled={{shadowEnabled}}>
      <three-renderer antialias={{antialias}} clearColor="{{clearColor}}"></three-renderer>
      <three-scene id="scene" defaultLight={{defaultLight}}>
        <content></content>
      </three-scene>
    </three-engine>
  </template>
  <script>
    Polymer({
      defaultLight: false,
      shadowEnabled: false,
      needDefaultLight: false,
      domReady: function() {
        if (this.defaultLight) {
          /*
          <template if={{needDefaultLight}}>
            <three-directional-light position="0.577,0.577,0.577" color="#cccccc"></three-light>
            <three-ambient-light color="#333333"></three-light>
          </template>
          this.needDefaultLight = true;
          */
          var directionalLight = document.createElement('three-directional-light');
          //directionalLight.setAttribute('position', '0.577,0.577,0.577');
          directionalLight.setAttribute('position', '100,100,100');
          directionalLight.setAttribute('color', '#cccccc');
          directionalLight.isSetup = false;
          this.$.scene.appendChild(directionalLight);
          var ambientLight = document.createElement('three-ambient-light');
          ambientLight.setAttribute('color', '#333333');
          ambientLight.isSetup = false;
          this.$.scene.appendChild(ambientLight);
        }
        var threejs = this.shadowRoot.children[0];
        this['addEventListener'] = function(eventName, handler) {
          threejs.addEventListener(eventName, handler);
        };
        threejs.setup();
        this.renderer = threejs.renderer;
        this.scene = threejs.scene;
        this.camera = threejs.camera;
        threejs.start();
      },
      getObjectByName: function(name) {
        return this.scene.getObjectByName(name);
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-light" extends="three-object3d" attributes="type,color">
  <script>
    Polymer({
      type: 'directional',
      color: '#ffffff',
      ready: function() {
        if (this.localName === 'three-light') {
          THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-light');
        }
      },
      setup: function() {
        this.object = this.light;
        this.super();
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-directional-light" extends="three-light" attributes="intensity,castShadow,onlyShadow,shadowCameraNear,shadowCameraFar,shadowCameraLeft,shadowCameraRight,shadowCameraTop,shadowCameraBottom,shadowCameraVisible,shadowBias,shadowDarkness,shadowMapWidth,shadowMapHeight">
  <script>
    Polymer({
      intensity: 1,
      castShadow: false,
      onlyShadow: false,
      shadowCameraNear: 50,
      shadowCameraFar: 5000,
      shadowCameraLeft: -500,
      shadowCameraRight: 500,
      shadowCameraTop: 500,
      shadowCameraBottom: -500,
      shadowCameraVisible: false,
      shadowBias: 0,
      shadowDarkness: 0.5,
      shadowMapWidth: 512,
      shadowMapHeight: 512,
      ready: function() {
        this.setup();
      },
      setup: function() {
        if (this.isSetup) return;
        this.light = new THREE.DirectionalLight(new THREE.Color(this.color));
        this.light.position.copy(THREE.Element.Utils.vector3(this.position));
        this.light.shadowMapWidth = this.shadowMapWidth;
        this.light.shadowMapHeight = this.shadowMapHeight;
        this.super();
        this.isSetup = true;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-ambient-light" extends="three-light" attributes="">
  <script>
    Polymer({
      ready: function() {
        this.setup();
      },
      setup: function() {
        if (this.isSetup) return;
        this.light = new THREE.AmbientLight(new THREE.Color(this.color));
        this.super();
        this.isSetup = true;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-mesh" extends="three-object3d">
  <script>
    Polymer({
      isMesh: true,
      setup: function() {
        var material;
        var geometries = [];
        var meshes = [];
        Array.apply(null, this.children).forEach(function(child) {
          if (child.setup) child.setup();
          if (child.material) material = child.material;
          if (child.geometry) geometries.push(child.geometry);
          if (child.isMesh) {
            meshes.push(child.mesh);
          }
          // TODO: should be refactored
          if (child.getDistributedNodes) {
            Array.apply(null, child.getDistributedNodes()).forEach(function(contentChild) {
              if (contentChild.setup) contentChild.setup();
              if (contentChild.material) material = contentChild.material;
              if (contentChild.geometry) geometries.push(contentChild.geometry);
              if (contentChild.isMesh) {
                meshes.push(contentChild.mesh);
              }
            }, this);
          }
        });
        var geometry = geometries.shift();
        while (0 < geometries.length) {
          geometry.merge(geometries.shift());
        }
        while (0 < meshes.length) {
          var mesh = meshes.shift();
          mesh.updateMatrix();
          geometry.merge(mesh.geometry, mesh.matrix);
        }
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.userData['element'] = this;
        this.mesh.position.copy(this.position);
        this.mesh.rotation.copy(this.rotation);
        this.mesh.scale.copy(this.scale);
        this.object = this.mesh;
        this.super();
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-loader-mesh" extends="three-object3d" attributes="type,src">
  <script>
    Polymer({
      type: 'json',
      setup: function() {
        this.mesh = new THREE.Mesh();
        if (this.type === 'json') {
          var loader = new THREE.JSONLoader(); 
          loader.load(this.src, function(geometry, materials) {
            this.mesh.geometry = geometry;
            this.mesh.material = materials[0];
            this.mesh.material.ambient = this.mesh.material.color;
          }.bind(this));
        }
        else if (this.type === 'obj') {
          var loader = new THREE.OBJLoader();
          loader.load(this.src, function(object) {
            object.children.forEach(function(child) {
              this.mesh.children.push(child);
            }.bind(this));
          }.bind(this));
        }
        this.object = this.mesh;
        this.super();
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-material" attributes="ref,type,side,opacity,transparent,blending,blendSrc,blendDst,blendEquation,depthTest,depthWrite,polygonOffset,polygonOffsetFactor,polygonOffsetUnits,alphaTest,overdraw,visible">
  <script>
    Polymer({
      type: 'mesh-phong',
      side: THREE.FrontSide,
      opacity: 1,
      transparent: false,
      blending: THREE.NormalBlending,
      blendSrc: THREE.SrcAlphaFactor,
      blendDst: THREE.OneMinusSrcAlphaFactor,
      blendEquation: THREE.AddEquation,
      depthTest: true,
      depthWrite: true,
      polygonOffset: false,
      polygonOffsetFactor: 0,
      polygonOffsetUnits: 0,
      alphaTest: 0,
      overdraw: 0,
      visible: true,
      isSetup: false,
      ready: function() {
        if (!this.ref && this.localName === 'three-material') {
          THREE.Element.Utils.replaceNodeName(this, 'three-' + this.type + '-material');
        }
      },
      setup: function() {
        if (this.isSetup) return;
        var elm = document.getElementById(this.ref);
        if (elm === null) {
          throw 'Element Not Found: #' + this.ref;
        }
        elm.setup();
        this.material = elm.material;
        this.isSetup = true;
      },
      getOptions: function() {
        if (this.opacity < 1) this.transparent = true;
        return {
          side: this.side,
          opacity: this.opacity,
          transparent: this.transparent,
          blending: this.blending,
          blendSrc: this.blendSrc,
          blendDst: this.blendDst,
          blendEquation: this.blendEquation,
          depthTest: this.depthTest,
          depthWrite: this.depthWrite,
          polygonOffset: this.polygonOffset,
          polygonOffsetFactor: this.polygonOffsetFactor,
          polygonOffsetUnits: this.polygonOffsetUnits,
          alphaTest: this.alphaTest,
          overdraw: this.overdraw,
          visible: this.visible
        };
      },
      opacityChanged: function(oldVal, newVal) {
        if (newVal < 1) this.material.transparent = true;
        this.material.opacity = newVal;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-mesh-phong-material" extends="three-material" attributes="color,ambient,emissive,specular,shininess,metal,map,bumpMap,bumpScale,fog,shading,wireframe">
  <script>
    Polymer({
      color: '#ffffff',
      ambient: '#ffffff',
      emissive: '#000000',
      specular: '#000000',
      shininess: 30,
      metal: false,
      bumpScale: 1,
      fog: true,
      shading: THREE.SmoothShading,
      wireframe: false,
      ready: function() {
        this.setup();
      },
      setup: function() {
        this.material = new THREE.MeshPhongMaterial(this.getOptions());
        if (typeof this.map !== 'undefined') {
          this.material.map = THREE.ImageUtils.loadTexture(this.map);
        }
        if (typeof this.bumpMap !== 'undefined') {
          this.material.bumpMap = THREE.ImageUtils.loadTexture(this.bumpMap);
        }
      },
      getOptions: function() {
        var opts = this.super();
        opts['color'] = new THREE.Color(this.color);
        opts['ambient'] = new THREE.Color(this.ambient);
        opts['emissive'] = new THREE.Color(this.emissive);
        opts['specular'] = new THREE.Color(this.specular);
        opts['shininess'] = this.shininess;
        opts['metal'] = this.metal;
        opts['bumpScale'] = this.bumpScale;
        opts['fog'] = this.fog;
        opts['shading'] = this.shading;
        opts['wireframe'] = this.wireframe;
        return opts;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-mesh-lambert-material" extends="three-material" attributes="color,ambient,emissive,wrapAround,wrapRGB,map,lightMap,specularMap,alphaMap,envMap,combine,reflectivity,refractionRatio,fog,shading,wireframe">
  <script>
    Polymer({
      color: '#ffffff',
      ambient: '#ffffff',
      emissive: '#000000',
      wrapAround: false,
      wrapRGB: '1,1,1',
      combine: THREE.MultiplyOperation,
      reflectivity: 1,
      refractionRatio: 0.98,
      fog: true,
      shading: THREE.SmoothShading,
      wireframe: false,
      ready: function() {
        this.setup();
      },
      setup: function() {
        this.material = new THREE.MeshPhongMaterial(this.getOptions());
        if (typeof this.map !== 'undefined') {
          this.material.map = THREE.ImageUtils.loadTexture(this.map);
        }
        if (typeof this.lightMap !== 'undefined') {
          this.material.lightMap = THREE.ImageUtils.loadTexture(this.lightMap);
        }
        if (typeof this.specularMap !== 'undefined') {
          this.material.specularMap = THREE.ImageUtils.loadTexture(this.specularMap);
        }
        if (typeof this.alphaMap !== 'undefined') {
          this.material.alphaMap = THREE.ImageUtils.loadTexture(this.alphaMap);
        }
        if (typeof this.envMap !== 'undefined') {
          this.material.envMap = THREE.ImageUtils.loadTexture(this.envMap);
        }
      },
      getOptions: function() {
        var opts = this.super();
        opts['color'] = new THREE.Color(this.color);
        opts['ambient'] = new THREE.Color(this.ambient);
        opts['emissive'] = new THREE.Color(this.emissive);
        opts['wrapAround'] = this.wrapAround;
        opts['wrapRGB'] = THREE.Element.Utils.vector3(this.wrapRGB);
        opts['combine'] = this.combine;
        opts['reflectivity'] = this.reflectivity;
        opts['refractionRatio'] = this.refractionRatio;
        opts['fog'] = this.fog;
        opts['shading'] = this.shading;
        opts['wireframe'] = this.wireframe;
        return opts;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-shader-material" extends="three-material" attributes="shading,linewidth,wireframe,wireframeLinewidth,fog,lights,vertexColors,skinning">
  <script>
    Polymer({
      shading: THREE.SmoothShading,
      linewidth: 1,
      wireframe: false,
      wireframeLinewidth: 1,
      fog: false,
      lights: false,
      vertexColors: THREE.NoColors,
      skinning: false,
      isSetup: false,
      domReady: function() {
        this.setup();
      },
      setup: function() {
        if (this.isSetup) return;
        var shaderOptions = {};
        Array.apply(null, this.children).forEach(function(child) {
          if (child.setup) child.setup(shaderOptions);
          if (child.getDistributedNodes) {
            Array.apply(null, child.getDistributedNodes()).forEach(function(contentChild) {
              if (contentChild.setup) contentChild.setup(shaderOptions);
            }, this);
          }
        }, this);
        this.material = new THREE.ShaderMaterial(shaderOptions);
        this.isSetup = true;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-vertex-shader">
  <template>
    <script type="x-shader/x-vertex">
      <content></content>
    </script>
  </template>
  <script>
    Polymer({
      setup: function(shaderOptions) {
        shaderOptions['vertexShader'] = this.textContent;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-fragment-shader">
  <template>
    <script type="x-shader/x-fragment">
      <content></content>
    </script>
  </template>
  <script>
    Polymer({
      setup: function(shaderOptions) {
        shaderOptions['fragmentShader'] = this.textContent;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-shader-uniforms">
  <script>
    Polymer({
      setup: function(shaderOptions) {
        shaderOptions['uniforms'] = {};
        Array.apply(null, this.children).forEach(function(child) {
          if (child.setup) child.setup(shaderOptions['uniforms']);
          if (child.getDistributedNodes) {
            Array.apply(null, child.getDistributedNodes()).forEach(function(contentChild) {
              if (contentChild.setup) contentChild.setup(shaderOptions['uniforms']);
            }, this);
          }
        }, this);
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-shader-attributes">
  <script>
    Polymer({
      setup: function(shaderOptions) {
        shaderOptions['attributes'] = {};
        Array.apply(null, this.children).forEach(function(child) {
          if (child.setup) child.setup(shaderOptions['attributes']);
          if (child.getDistributedNodes) {
            Array.apply(null, child.getDistributedNodes()).forEach(function(contentChild) {
              if (contentChild.setup) contentChild.setup(shaderOptions['attributes']);
            }, this);
          }
        }, this);
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-shader-variable" attributes="name,type,value">
  <template>
    <style>
      #container {display:none}
    </style>
    <div id="container">
      <content></content>
    </div>
  </template>
  <script>
    Polymer({
      setup: function(variableOptions) {
        variableOptions[this.name] = {type: this.type, value: eval(this.value)};
        return this.textContent;
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-geomerty">
  <script>
    Polymer({
    });
  </script>
</polymer-element>

<polymer-element name="three-box-geometry" extends="three-geomerty" attributes="width,height,depth,widthSegments,heightSegments,depthSegments">
  <script>
    Polymer({
      width: 1,
      height: 1,
      depth: 1,
      widthSegments: 1,
      heightSegments: 1,
      depthSegments: 1,
      ready: function() {
        this.setup();
      },
      setup: function() {
        this.geometry = new THREE.BoxGeometry(this.width, this.height, this.depth, Math.floor(this.widthSegments), Math.floor(this.heightSegments), Math.floor(this.depthSegments));
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-circle-geometry" extends="three-geomerty" attributes="radius,segments,thetaStart,thetaLength">
  <script>
    Polymer({
      radius: 50,
      segments: 32,
      thetaStart: 0,
      thetaLength: Math.PI * 2,
      ready: function() {
        this.setup();
      },
      setup: function() {
        this.geometry = new THREE.CircleGeometry(this.radius, this.segments, this.thetaStart, this.thetaLength);
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-cylinder-geometry" extends="three-geomerty" attributes="radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength">
  <script>
    Polymer({
      radiusTop: 20.0,
      radiusBottom: 20.0,
      height: 100.0,
      radialSegments: 32,
      heightSegments: 1,
      openEnded: false,
      thetaStart: 0,
      thetaLength: 2 * Math.PI,
      ready: function() {
        this.setup();
      },
      setup: function() {
        this.geometry = new THREE.CylinderGeometry(this.radiusTop, this.radiusBottom, this.height, this.radialSegments, this.heightSegments, this.openEnded, this.thetaStart, this.thetaLength);
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-plane-geometry" extends="three-geomerty" attributes="width,height,widthSegments,heightSegments">
  <script>
    Polymer({
      width: 1,
      height: 1,
      widthSegments: 1,
      heightSegments: 1,
      ready: function() {
        this.setup();
      },
      setup: function() {
        this.geometry = new THREE.PlaneBufferGeometry(this.width, this.height, this.widthSegments, this.heightSegments);
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-sphere-geometry" extends="three-geomerty" attributes="radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength">
  <script>
    Polymer({
      radius: 50,
      widthSegments: 32,
      heightSegments: 16,
      phiStart: 0,
      phiLength: Math.PI * 2,
      thetaStart: 0,
      thetaLength: Math.PI,
      ready: function() {
        this.setup();
      },
      setup: function() {
        this.geometry = new THREE.SphereGeometry(this.radius, this.widthSegments, this.heightSegments, this.phiStart, this.phiLength, this.thetaStart, this.thetaLength);
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-torus-geometry" extends="three-geomerty" attributes="radius,tube,radialSegments,tubularSegments,arc">
  <script>
    Polymer({
      radius: 100,
      tube: 40,
      radialSegments: 16,
      tubularSegments: 32,
      arc: Math.PI * 2,
      ready: function() {
        this.setup();
      },
      setup: function() {
        this.geometry = new THREE.TorusGeometry(this.radius, this.tube, this.radialSegments, this.tubularSegments, this.arc);
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-mesh-phong-materialized-mesh" extends="three-object3d" attributes="side,opacity,transparent,blending,blendSrc,blendDst,blendEquation,depthTest,depthWrite,polygonOffset,polygonOffsetFactor,polygonOffsetUnits,alphaTest,overdraw,visible,color,ambient,emissive,specular,shininess,metal,map,bumpMap,bumpScale,fog,shading,wireframe">
  <template>
    <three-mesh name="{{name}}" position="{{position}}" rotation="{{rotation}}" scale="{{scale}}">
      <three-mesh-phong-material
        side="{{side}}"
        opacity="{{opacity}}"
        transparent="{{transparent}}"
        blending="{{blending}}"
        blendSrc="{{blendSrc}}"
        blendDst="{{blendDst}}"
        blendEquation="{{blendEquation}}"
        depthTest="{{depthTest}}"
        depthWrite="{{depthWrite}}"
        polygonOffset="{{polygonOffset}}"
        polygonOffsetFactor="{{polygonOffsetFactor}}"
        polygonOffsetUnits="{{polygonOffsetUnits}}"
        alphaTest="{{alphaTest}}"
        overdraw="{{overdraw}}"
        visible="{{visible}}"
        color="{{color}}"
        ambient="{{ambient}}"
        emissive="{{emissive}}"
        specular="{{specular}}"
        shininess="{{shininess}}"
        metal="{{metal}}"
        map="{{map}}"
        bumpMap="{{bumpMap}}"
        bumpScale="{{bumpScale}}"
        fog="{{fog}}"
        shading="{{shading}}"
        wireframe="{{wireframe}}">
      </three-mesh-phong-material>
      <content></content>
    </three-mesh>
  </template>
  <script>
    Polymer({
      isMesh: true,
      setup: function(threejs) {
        var child = this.shadowRoot.children[0].shadowRoot.children[0];
        child.setup(threejs);
        this.object = child.object
        this.mesh = this.object;
        this.mesh.userData['element'] = this;
        this.super();
      }
    });
  </script>
</polymer-element>

<polymer-element name="three-box" extends="three-mesh-phong-materialized-mesh" attributes="width,height,depth,widthSegments,heightSegments,depthSegments">
  <template>
    <three-mesh-phong-materialized-mesh
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      side="{{side}}"
      opacity="{{opacity}}"
      jransparent="{{transparent}}"
      blending="{{blending}}"
      blendSrc="{{blendSrc}}"
      blendDst="{{blendDst}}"
      blendEquation="{{blendEquation}}"
      depthTest="{{depthTest}}"
      depthWrite="{{depthWrite}}"
      polygonOffset="{{polygonOffset}}"
      polygonOffsetFactor="{{polygonOffsetFactor}}"
      polygonOffsetUnits="{{polygonOffsetUnits}}"
      alphaTest="{{alphaTest}}"
      overdraw="{{overdraw}}"
      visible="{{visible}}"
      color="{{color}}"
      ambient="{{ambient}}"
      emissive="{{emissive}}"
      specular="{{specular}}"
      shininess="{{shininess}}"
      metal="{{metal}}"
      map="{{map}}"
      bumpMap="{{bumpMap}}"
      bumpScale="{{bumpScale}}"
      fog="{{fog}}"
      shading="{{shading}}"
      wireframe="{{wireframe}}">
      <three-box-geometry
        width="{{width}}"
        height="{{height}}"
        depth="{{depth}}"
        widthSegments="{{widthSegments}}"
        heightSegments="{{heightSegments}}"
        depthSegments="{{depthSegments}}">
      </three-box-geometry>
      <content></content>
    </three-mesh-phong-materialized-mesh>
  </template>
  <script>
    Polymer({
      width: 1,
      height: 1,
      depth: 1,
      widthSegments: 1,
      heightSegments: 1,
      depthSegments: 1
    });
  </script>
</polymer-element>

<polymer-element name="three-circle" extends="three-mesh-phong-materialized-mesh" attributes="radius,segments,thetaStart,thetaLength">
  <template>
    <three-mesh-phong-materialized-mesh
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      side="{{side}}"
      opacity="{{opacity}}"
      transparent="{{transparent}}"
      blending="{{blending}}"
      blendSrc="{{blendSrc}}"
      blendDst="{{blendDst}}"
      blendEquation="{{blendEquation}}"
      depthTest="{{depthTest}}"
      depthWrite="{{depthWrite}}"
      polygonOffset="{{polygonOffset}}"
      polygonOffsetFactor="{{polygonOffsetFactor}}"
      polygonOffsetUnits="{{polygonOffsetUnits}}"
      alphaTest="{{alphaTest}}"
      overdraw="{{overdraw}}"
      visible="{{visible}}"
      color="{{color}}"
      ambient="{{ambient}}"
      emissive="{{emissive}}"
      specular="{{specular}}"
      shininess="{{shininess}}"
      metal="{{metal}}"
      map="{{map}}"
      bumpMap="{{bumpMap}}"
      bumpScale="{{bumpScale}}"
      fog="{{fog}}"
      shading="{{shading}}"
      wireframe="{{wireframe}}">
      <three-circle-geometry
        radius="{{radius}}"
        segments="{{segments}}"
        thetaStart="{{thetaStart}}"
        thetaLength="{{thetaLength}}">
      </three-circle-geometry>
    </three-mesh-phong-materialized-mesh>
  </template>
  <script>
    Polymer({
      radius: 50,
      segments: 32,
      thetaStart: 0,
      thetaLength: Math.PI * 2
    });
  </script>
</polymer-element>

<polymer-element name="three-cylinder" extends="three-mesh-phong-materialized-mesh" attributes="radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength">
  <template>
    <three-mesh-phong-materialized-mesh
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      side="{{side}}"
      opacity="{{opacity}}"
      transparent="{{transparent}}"
      blending="{{blending}}"
      blendSrc="{{blendSrc}}"
      blendDst="{{blendDst}}"
      blendEquation="{{blendEquation}}"
      depthTest="{{depthTest}}"
      depthWrite="{{depthWrite}}"
      polygonOffset="{{polygonOffset}}"
      polygonOffsetFactor="{{polygonOffsetFactor}}"
      polygonOffsetUnits="{{polygonOffsetUnits}}"
      alphaTest="{{alphaTest}}"
      overdraw="{{overdraw}}"
      visible="{{visible}}"
      color="{{color}}"
      ambient="{{ambient}}"
      emissive="{{emissive}}"
      specular="{{specular}}"
      shininess="{{shininess}}"
      metal="{{metal}}"
      map="{{map}}"
      bumpMap="{{bumpMap}}"
      bumpScale="{{bumpScale}}"
      fog="{{fog}}"
      shading="{{shading}}"
      wireframe="{{wireframe}}">
      <three-cylinder-geometry
        radiusTop="{{radiusTop}}"
        radiusBottom="{{radiusBottom}}"
        height="{{height}}"
        radialSegments="{{radialSegments}}"
        heightSegments="{{heightSegments}}"
        openEnded="{{openEnded}}"
        thetaStart="{{thetaStart}}"
        thetaLength="{{thetaLength}}">
      </three-cylinder-geometry>
    </three-mesh-phong-materialized-mesh>
  </template>
  <script>
    Polymer({
      radiusTop: 20.0,
      radiusBottom: 20.0,
      height: 100.0,
      radialSegments: 32,
      heightSegments: 1,
      openEnded: false,
      thetaStart: 0,
      thetaLength: 2 * Math.PI
    });
  </script>
</polymer-element>

<polymer-element name="three-plane" extends="three-mesh-phong-materialized-mesh" attributes="width,height,widthSegments,heightSegments">
  <template>
    <three-mesh-phong-materialized-mesh
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      side="{{side}}"
      opacity="{{opacity}}"
      transparent="{{transparent}}"
      blending="{{blending}}"
      blendSrc="{{blendSrc}}"
      blendDst="{{blendDst}}"
      blendEquation="{{blendEquation}}"
      depthTest="{{depthTest}}"
      depthWrite="{{depthWrite}}"
      polygonOffset="{{polygonOffset}}"
      polygonOffsetFactor="{{polygonOffsetFactor}}"
      polygonOffsetUnits="{{polygonOffsetUnits}}"
      alphaTest="{{alphaTest}}"
      overdraw="{{overdraw}}"
      visible="{{visible}}"
      color="{{color}}"
      ambient="{{ambient}}"
      emissive="{{emissive}}"
      specular="{{specular}}"
      shininess="{{shininess}}"
      metal="{{metal}}"
      map="{{map}}"
      bumpMap="{{bumpMap}}"
      bumpScale="{{bumpScale}}"
      fog="{{fog}}"
      shading="{{shading}}"
      wireframe="{{wireframe}}">
      <three-plane-geometry
        width="{{width}}"
        height="{{height}}"
        widthSegments="{{widthSegments}}"
        heightSegments="{{heightSegments}}">
      </three-plane-geometry>
    </three-mesh-phong-materialized-mesh>
  </template>
  <script>
    Polymer({
      width: 1,
      height: 1,
      widthSegments: 1,
      heightSegments: 1
    });
  </script>
</polymer-element>

<polymer-element name="three-sphere" extends="three-mesh-phong-materialized-mesh" attributes="radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength">
  <template>
    <three-mesh-phong-materialized-mesh
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      side="{{side}}"
      opacity="{{opacity}}"
      transparent="{{transparent}}"
      blending="{{blending}}"
      blendSrc="{{blendSrc}}"
      blendDst="{{blendDst}}"
      blendEquation="{{blendEquation}}"
      depthTest="{{depthTest}}"
      depthWrite="{{depthWrite}}"
      polygonOffset="{{polygonOffset}}"
      polygonOffsetFactor="{{polygonOffsetFactor}}"
      polygonOffsetUnits="{{polygonOffsetUnits}}"
      alphaTest="{{alphaTest}}"
      overdraw="{{overdraw}}"
      visible="{{visible}}"
      color="{{color}}"
      ambient="{{ambient}}"
      emissive="{{emissive}}"
      specular="{{specular}}"
      shininess="{{shininess}}"
      metal="{{metal}}"
      map="{{map}}"
      bumpMap="{{bumpMap}}"
      bumpScale="{{bumpScale}}"
      fog="{{fog}}"
      shading="{{shading}}"
      wireframe="{{wireframe}}">
      <three-sphere-geometry
        radius="{{radius}}"
        widthSegments="{{widthSegments}}"
        heightSegments="{{heightSegments}}"
        phiStart="{{phiStart}}"
        phiLength="{{phiLength}}"
        thetaStart="{{thetaStart}}"
        thetaLength="{{thetaLength}}">
      </three-sphere-geometry>
      <content></content>
    </three-mesh-phong-materialized-mesh>
  </template>
  <script>
    Polymer({
      radius: 50,
      widthSegments: 32,
      heightSegments: 16,
      phiStart: 0,
      phiLength: Math.PI * 2,
      thetaStart: 0,
      thetaLength: Math.PI
    });
  </script>
</polymer-element>

<polymer-element name="three-torus" extends="three-mesh-phong-materialized-mesh" attributes="radius,tube,radialSegments,tubularSegments,arc">
  <template>
    <three-mesh-phong-materialized-mesh
      position="{{position}}"
      rotation="{{rotation}}"
      scale="{{scale}}"
      side="{{side}}"
      opacity="{{opacity}}"
      transparent="{{transparent}}"
      blending="{{blending}}"
      blendSrc="{{blendSrc}}"
      blendDst="{{blendDst}}"
      blendEquation="{{blendEquation}}"
      depthTest="{{depthTest}}"
      depthWrite="{{depthWrite}}"
      polygonOffset="{{polygonOffset}}"
      polygonOffsetFactor="{{polygonOffsetFactor}}"
      polygonOffsetUnits="{{polygonOffsetUnits}}"
      alphaTest="{{alphaTest}}"
      overdraw="{{overdraw}}"
      visible="{{visible}}"
      color="{{color}}"
      ambient="{{ambient}}"
      emissive="{{emissive}}"
      specular="{{specular}}"
      shininess="{{shininess}}"
      metal="{{metal}}"
      map="{{map}}"
      bumpMap="{{bumpMap}}"
      bumpScale="{{bumpScale}}"
      fog="{{fog}}"
      shading="{{shading}}"
      wireframe="{{wireframe}}">
      <three-torus-geometry
        radius="{{radius}}"
        tube="{{tube}}"
        radialSegments="{{radialSegments}}"
        tubularSegments="{{tubularSegments}}"
        arc="{{arc}}">
      </three-torus-geometry>
    </three-mesh-phong-materialized-mesh>
  </template>
  <script>
    Polymer({
      radius: 100,
      tube: 40,
      radialSegments: 16,
      tubularSegments: 32,
      arc: Math.PI * 2
    });
  </script>
</polymer-element>

<polymer-element name="three-controls" attributes="type,center,movementSpeed,rollSpeed,lookSpeed,lon,noFly">
  <script>
    Polymer({
      setup: function(camera, canvas) {
        if (this.type === 'orbit') {
          this.controls = new THREE.OrbitControls(camera, canvas);
          this.controls.target.copy(THREE.Element.Utils.vector3(this.center));
        }
        else if (this.type === 'fly') {
          this.controls = new THREE.FlyControls(camera, canvas);
          if (typeof this.movementSpeed !== 'undefined') {
            this.controls.movementSpeed = parseFloat(this.movementSpeed);
          }
          if (typeof this.rollSpeed !== 'undefined') {
            this.controls.rollSpeed = parseFloat(this.rollSpeed);
          }
        }
        else if (this.type === 'firstperson') {
          this.controls = new THREE.FirstPersonControls(camera, canvas);
          if (typeof this.movementSpeed !== 'undefined') {
            this.controls.movementSpeed = parseFloat(this.movementSpeed);
          }
          if (typeof this.lookSpeed !== 'undefined') {
            this.controls.lookSpeed = parseFloat(this.lookSpeed);
          }
          if (typeof this.lon !== 'undefined') {
            this.controls.lon = parseFloat(this.lon);
          }
          if (typeof this.noFly !== 'undefined') {
            this.controls.noFly = this.noFly === 'true';
          }
        }
        else {
          throw 'Unknown type: ' + this.type;
        }
      }
    });
  </script>
</polymer-element>
